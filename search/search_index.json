{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DH5. Dictionary H5","text":"<p>The <code>Dictionary H5</code> provides an intuitive interface for manipulating HDF5 files, allowing them to be handled like traditional Python dictionaries.</p> <ul> <li> <p>Concerned about losing your data in case of a kernel crash?   <code>DH5</code> has a save_on_edit method to ensure your data is always saved.</p> </li> <li> <p>Need to update a single element in an array without a full re-save?   No problem \u2013 <code>DH5</code> only updates the changes you make.</p> </li> <li> <p>Want to save tricky data like strings, mixed object arrays, or even functions, which can be challenging with <code>h5py</code>?   <code>DH5</code> simplifies the process of saving a wide variety of object types.</p> </li> </ul>"},{"location":"#features","title":"Features:","text":"<ul> <li>Dictionary-like Interface: Access and modify HDF5 files using familiar dictionary syntax.</li> <li>Save on Edit: Automatically save changes to the file without manually calling a save method (when <code>save_on_edit=True</code> is provided).</li> <li>Multiple Opening Modes: Open files in different modes like 'read', 'write', and 'append'.</li> <li>Key Locking: Lock specific keys to prevent their modification.</li> </ul> <p>Give <code>dh5</code> a try and streamline your data management.</p>"},{"location":"#install","title":"Install","text":"<p><code>pip install dh5</code></p> <p>More on it can be found inside the installation guide</p>"},{"location":"#usage","title":"Usage","text":"<pre><code># Save {'a': 5} to `somedata.h5`\n&gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n&gt;&gt;&gt; sd['a'] = 5\n&gt;&gt;&gt; sd.save()\n\n# Open 'somedata.h5' in read mode\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a'] # access data as an item\n5\n&gt;&gt;&gt; sd_read.a # access data as an attribute\n5\n\n# Open 'somedata.h5' in append mode. Allows to add data to existing file.\n&gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n&gt;&gt;&gt; sd_append['b'] = 6\n&gt;&gt;&gt; sd_append.save()\n\n# In the end, `samedata.h5` contains {'a': 5, 'b': 6}\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a'], sd_read['b']\n(5, 6)\n</code></pre> <p>For further insight, please refer to the First Steps guide.</p> <p>For more in-depth information, explore the Advanced Examples.</p> <p>To gain a comprehensive understanding of syntax, visit the DH5 Class Page.</p>"},{"location":"about/","title":"About dh5","text":"<p>The Dh5 (Dictionary H5) library was developed with the primary goal of enhancing data storage efficiency within the OMQ group at LKB lab in Paris. Its key objective is to guarantee data preservation, ensuring that valuable information remains accessible over extended periods.</p> <p>This library has undergone meticulous testing, including comprehensive unit tests and real-world workflow assessments. Consequently, it is capable of seamlessly handling various types of data while maintaining a user-friendly with classical dictionary syntax.</p>"},{"location":"develop/","title":"Heritage","text":""},{"location":"develop/#dataclasses","title":"Dataclasses","text":""},{"location":"develop/data_transformation/","title":"Data transformation","text":"<p>Data transformation page</p>"},{"location":"dh5/","title":"DH5.","text":"<p>This page contains all DH5 class methods. If you wonder how to start with <code>dh5</code> library, please refer to the First Steps guide.</p> <p>DH5 - Dict that is synchronized with .h5 file.</p>"},{"location":"dh5/#dh5.DH5--usage-and-initialization","title":"Usage and initialization","text":"<p>DH5 can open files in 3 different modes:</p> <ul> <li>'r' - Read mode. No data chan be modified.</li> <li>'w' - Write mode. If file exists it will be overwritten. And you have full control on data.</li> <li>'a' - Append mode. If file exists it will be opened. And you have full control on data.</li> </ul> <p>To overwrite file use <code>open_overwrite</code> method or <code>mode=\"w\"</code> with <code>overwrite=True</code>.</p>"},{"location":"dh5/#dh5.DH5--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n&gt;&gt;&gt; sd['a'] = 5\n&gt;&gt;&gt; sd.save()\n\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a']\n5\n&gt;&gt;&gt; sd_read.a\n5\n\n&gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n&gt;&gt;&gt; sd_append['b'] = 6\n&gt;&gt;&gt; sd_append.save()\n\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a'], sd_read['b']\n(5, 6)\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>class DH5:\n    \"\"\"DH5 - Dict that is synchronized with .h5 file.\n\n    # Usage and initialization\n    DH5 can open files in 3 different modes:\n\n    - 'r' - Read mode. No data chan be modified.\n    - 'w' - Write mode. If file exists it will be overwritten. And you have full control on data.\n    - 'a' - Append mode. If file exists it will be opened. And you have full control on data.\n\n    To overwrite file use `open_overwrite` method or `mode=\"w\"` with `overwrite=True`.\n\n\n    # Examples\n        &gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n        &gt;&gt;&gt; sd['a'] = 5\n        &gt;&gt;&gt; sd.save()\n\n        &gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n        &gt;&gt;&gt; sd_read['a']\n        5\n        &gt;&gt;&gt; sd_read.a\n        5\n\n        &gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n        &gt;&gt;&gt; sd_append['b'] = 6\n        &gt;&gt;&gt; sd_append.save()\n\n        &gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n        &gt;&gt;&gt; sd_read['a'], sd_read['b']\n        (5, 6)\n\n    \"\"\"\n\n    _repr: Optional[str] = None\n    _default_attr = [\"get\", \"items\", \"keys\", \"pop\", \"update\", \"values\", \"save\"]\n    _last_data_saved: bool = False\n    _filepath: Optional[str] = None\n    _read_only: Union[bool, Set[str]]\n    _raise_file_locked_error: bool = False\n    _retry_on_file_locked_error: int = 5\n    _last_time_data_checked: float = 0\n    _file_modified_time: float = 0\n    __should_initialized: bool = False\n    __should_not_be_converted__ = True\n\n    def __init__(\n        self,\n        filepath_or_data: Optional[Union[str, dict, Path]] = None,\n        /,\n        mode: Optional[Literal[\"r\", \"w\", \"a\", \"w=\", \"a=\"]] = None,\n        *,\n        filepath: Optional[Union[str, Path]] = None,\n        save_on_edit: bool = False,\n        read_only: Optional[Union[bool, Set[str]]] = None,\n        overwrite: Optional[bool] = None,\n        data: Optional[dict] = None,\n        open_on_init: Optional[bool] = None,\n        **kwds,\n    ):\n        \"\"\"DH5.\n\n        Args:\n            filepath_or_data (str|dict, optional): either filepath, either data as dict.\n            filepath (str|Path, optional): filepath to load. Defaults to None.\n            save_on_edit (bool, optional): Save data as soon as you changed it.\n                Defaults to False. And data should be saved using `save()` method.\n            read_only (bool, optional): opens file in read_only mode, i.e. it cannot be modified.\n                Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.\n            overwrite (Optional[bool], optional):\n                If file exists, it should be explicitly precised.\n                By default raises an error if file exist.\n            data (Optional[dict], optional):\n                Data to load. If data provided, file . Defaults to None.\n            open_on_init (Optional[bool], optional): open_on_init. Defaults to True.\n\n        \"\"\"\n        if mode is not None:\n            if mode.startswith(\"w\"):\n                read_only = False\n            elif mode.startswith(\"a\"):\n                read_only = False\n                overwrite = False\n            elif mode == \"r\":\n                read_only = True\n            if mode.endswith(\"=\"):\n                save_on_edit = True\n\n        if filepath_or_data is not None and hasattr(filepath_or_data, \"keys\"):\n            if not isinstance(filepath_or_data, dict):\n                filepath_or_data = {key: filepath_or_data[key] for key in filepath_or_data.keys()}  # type: ignore\n            data = data or filepath_or_data\n\n        if isinstance(filepath_or_data, (str, Path)):\n            filepath = filepath or filepath_or_data\n\n        if filepath and not isinstance(filepath, str):\n            filepath = str(filepath)\n\n        self._data: Dict[str, Any] = data or {}\n        # transform_to_possible_formats(self._data)\n        self._keys: Set[str] = set(self._data.keys())\n        self._last_update = set()\n        self._save_on_edit = save_on_edit\n        self._classes_should_be_saved_internally = set()\n        self._key_prefix: Optional[str] = kwds.get(\"key_prefix\")\n\n        if read_only is None:\n            read_only = (\n                save_on_edit is False and not overwrite\n            ) and filepath is not None\n\n        if open_on_init is False and overwrite is True:\n            raise ValueError(\"Cannot overwrite file and open_on_init=False mode\")\n        self._open_on_init = (\n            open_on_init if open_on_init is not None else (None if self._data else True)\n        )\n        self._unopened_keys = set()\n\n        # if keep_up_to_data and read_only is True:\n        # raise ValueError(\"Cannot open file in read-only and keep_up_to_data=True mode\")\n        # self._keep_up_to_data = keep_up_to_data\n\n        self._read_only = read_only\n        if filepath is not None:\n            filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n\n            if (overwrite or save_on_edit) and read_only:\n                raise ValueError(\n                    \"\"\"Cannot open file in read_only mode and overwrite it.\"\"\"\n                )\n\n            if os.path.exists(filepath):\n                if overwrite is None and not read_only:\n                    raise FileExistsError(\n                        \"File with the same name already exists. So you should explicitly \"\n                        \"provide what to do with it. Set `overwrite=True` to replace file. \"\n                        \"Set `overwrite=False` if you want to open existing file and work with it.\"\n                    )\n\n                if overwrite and not read_only:\n                    self.__should_initialized = True\n                    # os.remove(filepath)\n\n                if read_only or (not read_only and not overwrite):\n                    if self._open_on_init:\n                        self._load_from_h5(filepath)\n                    elif self._open_on_init is False:\n                        self._keys = h5py_utils.keys_h5(\n                            filepath, key_prefix=self._key_prefix\n                        )\n                        self._unopened_keys.update(self._keys)\n\n            elif read_only:\n                raise ValueError(\n                    f\"Cannot open file in read_only mode if file {filepath} does not exist\"\n                )\n\n            # if not read_only:\n            self._filepath = filepath\n\n    @classmethod\n    def open_overwrite(\n        cls,\n        filepath_or_data: Optional[Union[str, dict, Path]] = None,\n        /,\n        mode: Optional[Literal[\"=\"]] = None,\n        *,\n        filepath: Optional[Union[str, Path]] = None,\n        save_on_edit: bool = False,\n        read_only: Optional[Union[bool, Set[str]]] = None,\n        overwrite: Optional[bool] = True,\n        data: Optional[dict] = None,\n        open_on_init: Optional[bool] = None,\n        **kwds,\n    ):\n        \"\"\"Open file in the overwrite mode.\n\n        It deletes the file if it exists and then opens it in the write mode.\n        Same syntax as `__init__` method.\n        \"\"\"\n        mode_ = \"w=\" if mode == \"=\" else \"w\"\n        return cls(\n            filepath_or_data,\n            mode=mode_,\n            filepath=filepath,\n            save_on_edit=save_on_edit,\n            read_only=read_only,\n            overwrite=overwrite,\n            data=data,\n            open_on_init=open_on_init,\n            **kwds,\n        )\n\n    def __init__filepath__(\n        self, *, filepath: str, filekey: str, save_on_edit: bool = False, **_\n    ):\n        \"\"\"Initialize a filepath. It allows to save sub DH5 objects independently.\n\n        Args:\n            filepath (str): The path to the file to be synced.\n            filekey (str): The key prefix to use for the synced data.\n            save_on_edit (bool, optional): Whether to save the file automatically when it is edited. Defaults to False.\n            **kwargs: Additional keyword arguments to pass to the constructor.\n        \"\"\"\n        self._filepath = filepath\n        self._key_prefix = filekey\n        self._save_on_edit = save_on_edit\n\n    def _load_from_h5(\n        self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n    ) -&gt; Set[str]:\n        \"\"\"Load data from h5 to self._data.\"\"\"\n        filepath = filepath or self._filepath\n        if filepath is None:\n            raise ValueError(\"Filepath is not specified. So cannot load_h5\")\n        filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n        data = h5py_utils.open_h5(filepath, key=key, key_prefix=self._key_prefix)\n        self._file_modified_time = os.path.getmtime(filepath)\n        return self._update(data)\n\n    def load(\n        self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n    ):\n        \"\"\"Load data from h5 into current object.\"\"\"\n        updated_from_other_file = filepath is not None\n        updated_key = self._load_from_h5(filepath=filepath, key=key)\n        if updated_from_other_file:\n            for key in updated_key:\n                self._keys.add(key)\n\n        return self\n\n    def lock_data(self: _SELF, keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n        \"\"\"Locks the specified keys in the database so they cannot be changed.\n\n        Args:\n            keys: An optional iterable of strings representing the keys to be locked.\n            If None, all keys will be locked.\n\n        Returns:\n            A reference to the DH5 object.\n\n        Raises:\n            ValueError: If everything is already locked by read_only mode.\n\n        Examples:\n            &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n            &gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n            &gt;&gt;&gt; sd['key1'] = 2\n            ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n            &gt;&gt;&gt; sd['key2'] = 5\n\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\n                \"Cannot lock specific data and everything is locked by read_only mode\"\n            )\n        if not isinstance(self._read_only, set):\n            self._read_only = set()\n        if keys is None:\n            keys = self.keys()\n        elif isinstance(keys, str):\n            keys = (keys,)\n\n        for key in keys:\n            self._read_only.add(key)\n\n        self._clean_precalculated_results()\n        return self\n\n    def unlock_data(self: _SELF, remove_keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n        \"\"\"Unlock the specified keys in the database so they can be changed.\n\n        If file was opened in read-only mode you cannot unlock it, however you can open\n        it again in 'a' mode and lock all keys except necessary.\n\n        Args:\n            keys: An optional iterable of strings representing the keys to be unlocked.\n            If None, all keys will be unlocked.\n\n        Returns:\n            A reference to the DH5 object.\n\n        Raises:\n            ValueError: If everything is already locked by read_only mode.\n\n        Examples:\n            &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n            &gt;&gt;&gt; sd.lock_data()\n            &gt;&gt;&gt; sd.unlock_data('key2')\n            &gt;&gt;&gt; sd['key2'] = 5\n            &gt;&gt;&gt; sd['key1'] = 2\n            ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\"Cannot unlock is global read_only mode was set to True\")\n        if isinstance(self._read_only, set):\n            if remove_keys is None:\n                self._read_only = False\n            else:\n                if isinstance(remove_keys, str):\n                    remove_keys = (remove_keys,)\n                for key in remove_keys:\n                    if key in self._read_only:\n                        self._read_only.remove(key)\n\n        self._clean_precalculated_results()\n        return self\n\n    def _clean_precalculated_results(self):\n        self._repr = None\n\n    def __add_key(self, key):\n        self._pre_save()\n        self._keys.add(key)\n        self._last_update.add(key)\n\n    def __del_key(self, key):\n        self._keys.remove(key)\n        self._last_update.add(key)\n\n    def __check_read_only_true(self, key):\n        \"\"\"Return true if data with this key is only available for read.\n\n        Takes into account the external constrains.\n        \"\"\"\n        return (self._read_only) and (self._read_only is True or key in self._read_only)\n\n    @editing\n    def update(\n        self: _SELF, __m: Optional[dict] = None, **kwds: \"DICT_OR_LIST_LIKE\"\n    ) -&gt; _SELF:\n        \"\"\"Update data from a dictionary or keyword arguments.\n\n        See `DH5.data_transformation` to learn more\n            about how the types are converted.\n\n        Args:\n            __m (dict | None): A dictionary of key-value pairs to update the DH5 object with.\n            **kwds (DICT_OR_LIST_LIKE): Keyword arguments of key-value pairs to update the DH5 object with.\n\n        Returns:\n            Self.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5()\n            &gt;&gt;&gt; data.update({'a': 1, 'b': 2})\n            DH5({'a': 1, 'b': 2})\n            &gt;&gt;&gt; data.update(c=3, d=4)\n            DH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n\n        \"\"\"\n        if __m is not None:\n            kwds.update(__m)\n\n        for key in kwds:  # pylint: disable=C0206\n            if self.__check_read_only_true(key):\n                raise ReadOnlyKeyError(key)\n            self.__add_key(key)\n            kwds[key] = transform_to_possible_formats(kwds[key])\n\n        # self.pull(auto=True)\n        self._data.update(**kwds)\n        return self\n\n    def _update(self, __m: Optional[dict] = None, **kwds: Any):\n        \"\"\"Update only internal data and attributes.\n\n        Can be modified in read_only mode. Did not change a file.\n        \"\"\"\n        if __m is not None:\n            kwds.update(__m)\n\n        for key in kwds:\n            self._keys.add(key)\n            self._unopened_keys.discard(key)\n\n        self._data.update(kwds)\n\n        return set(kwds.keys())\n\n    @editing\n    def pop(self, key: str) -&gt; Union[Any, NotLoaded]:\n        \"\"\"Remove the specified key and return the value.\n\n        Args:\n            key (str): The key to remove.\n\n        Returns:\n            Same as `get` method, i.e. `DH5` if the value is a dict otherwise the value.\n                If data was never loaded it will return `NotLoaded`. To load data use `get` method.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n            &gt;&gt;&gt; data.pop('b')\n            2\n\n        \"\"\"\n        if self.__check_read_only_true(key):\n            raise ReadOnlyKeyError(key, action=\"pop\")\n        self.__del_key(key)\n        # self.pull(auto=True)\n        if key not in self._unopened_keys:\n            return self._data.pop(key)\n        return NotLoaded()\n\n    @editing\n    def remove(self: _SELF, key: str) -&gt; _SELF:\n        \"\"\"Remove the specified key and self.\n\n        Args:\n            key (str): The key to remove.\n\n        Returns:\n            Self.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n            &gt;&gt;&gt; data.pop('b')\n            DH5({'a': 1, 'c': 3})\n\n        \"\"\"\n        self.pop(key)\n        return self\n\n    @overload\n    def get_raw(self, __key: str) -&gt; Any:\n        \"\"\"Return element as a dict. Return None if not found.\"\"\"\n\n    @overload\n    def get_raw(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"With default value provided.\"\"\"\n\n    def get_raw(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Return raw value associated with the given key.\n\n        Dictionaries are not converted to the `DH5` unlike `get` method.\n\n        Args:\n            key (str): Key to be searched.\n            default (Any, optional): Value to be returned if the `key` is not found.\n                The default value is `None`.\n\n\n        Returns:\n            Raw value without any conversion or the default value if the key is not found.\n\n        Examples:\n            &gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n            &gt;&gt;&gt; sync_data.get_raw('key1')\n            {'a': 1, 'b': 2}\n            &gt;&gt;&gt; sync_data.get_raw('key2')\n            5\n        \"\"\"\n        return self.__get_data__(key, default)\n\n    @overload\n    def get(self, __key: str) -&gt; Any:\n        \"\"\"Return element as a DH5 class if it's dict. Return None if not found.\"\"\"\n\n    @overload\n    def get(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"With default value provided.\"\"\"\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Retrieve the value associated with the given key from the DH5 object.\n\n        Args:\n            key (str): Key to be searched.\n            default (Any, optional): Value to be returned if the `key` is not found.\n                The default value is `None`.\n\n        Returns:\n            The value associated with the key. If the value is a dict then it's converter\n            into `DH5` object. This conversion take some time, but allow to change, save and\n            this sub-object. For faster performance use `get_raw` method.\n\n        Examples:\n            &gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n            &gt;&gt;&gt; sync_data.get('name')\n            'John'\n            &gt;&gt;&gt; sync_data.get('surname')\n            None\n            &gt;&gt;&gt; sync_data.get('gender', 'unknown')\n            'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n\n        \"\"\"\n        data = self.__get_data__(key, default)\n        if isinstance(data, dict) and data:\n            return DH5(\n                filepath=self._filepath,\n                data=data,\n                overwrite=False,\n                key_prefix=key,\n                read_only=self.__check_read_only_true(key),\n            )\n        return data\n\n    def __getitem__(self, __key: Union[str, tuple]) -&gt; Any:\n        \"\"\"Return raw value associated with the given key.\n\n        Same as `get_raw` but raises error if the key is not found.\n\n        Args:\n            key (str | tuple): The key to retrieve the dictionary for.\n\n        Returns:\n            Raw value without any conversion.\n\n        Raises:\n            KeyError: If the key is not found.\n\n        \"\"\"\n        if isinstance(__key, tuple):\n            if len(__key) &gt; 1:\n                return self.__getitem__(__key[0]).__getitem__(\n                    __key[1:] if len(__key) &gt; 2 else __key[1]\n                )\n            if len(__key) == 1:\n                return self.__getitem__(__key[0])\n            raise ValueError(\n                \"Key should be a string or tuple with at least one element\"\n            )\n        return self.__get_data_or_raise__(__key)\n\n    @editing\n    def __setitem__(\n        self, __key: Union[str, tuple], __value: \"DICT_OR_LIST_LIKE\"\n    ) -&gt; None:\n        \"\"\"Set value corresponding to the given key.\n\n        See [`DH5.data_transformation`](data_transformation.md) to learn more\n            about how the types are converted.\n\n        Args:\n            key (str | tuple): The key to retrieve the dictionary for.\n\n        \"\"\"\n        if isinstance(__key, tuple):\n            if not __key or len(__key) == 1 or len(__key) == 0:\n                raise ValueError(\n                    \"Key should be a string or tuple with at least two elements\"\n                )\n\n            self.__add_key(__key[0])\n            if self.__check_read_only_true(__key[0]):\n                raise ReadOnlyKeyError(__key[0], action=\"set\")\n            return self.__getitem__(__key[0]).__setitem__(\n                __key[1:] if len(__key) &gt; 2 else __key[1], __value  # type: ignore\n            )\n\n        if self.__check_read_only_true(__key):\n            raise ReadOnlyKeyError(__key, action=\"set\")\n\n        self.__add_key(__key)\n        __value = transform_to_possible_formats(__value)\n\n        if self._read_only is not True:\n            if hasattr(__value, \"save\"):\n                self._classes_should_be_saved_internally.add(__key)\n\n            if hasattr(__value, \"__init__filepath__\") and self._filepath:\n                key = (\n                    __key if self._key_prefix is None else f\"{self._key_prefix}/{__key}\"\n                )\n                __value.__init__filepath__(  # type: ignore\n                    filepath=self._filepath,\n                    filekey=key,\n                    save_on_edit=self._save_on_edit,\n                )\n\n            if hasattr(__value, \"__post__init__\"):\n                __value.__post__init__()  # type: ignore\n\n        self.__set_data__(__key, __value)\n        return None\n\n    def __delitem__(self, key: str):\n        self.pop(key)\n\n    def __getattr__(self, __name: str):\n        \"\"\"Call if __getattribute__ does not work.\"\"\"\n        if (\n            len(__name) &gt; 1\n            and __name[0] == \"i\"\n            and __name[1:].isdigit()\n            and __name not in self\n        ):\n            __name = __name[1:]\n        if __name in self:\n            data = self.get(__name)\n            # if isinstance(data, dict) and data:\n            #     return DH5(filepath=self._filepath, data=data, key_prefix=__name)\n            return data\n        raise AttributeError(f\"No attribute {__name} found in DH5\")\n\n    def __setattr__(self, __name: str, __value: \"DICT_OR_LIST_LIKE\") -&gt; None:\n        \"\"\"Call every time you set an attribute.\"\"\"\n        if __name.startswith(\"_\"):\n            return object.__setattr__(self, __name, __value)\n\n        if isinstance(vars(self.__class__).get(__name), property):\n            return object.__setattr__(self, __name, __value)\n        return self.__setitem__(__name, __value)\n\n    def __delattr__(self, __name: str) -&gt; None:\n        if __name in self:\n            return self.__delitem__(__name)\n        return object.__delattr__(self, __name)\n\n    @overload\n    def __get_data__(self, __key: str) -&gt; Optional[None]:\n        \"\"\"Return None if the data doesn't contain key.\"\"\"\n\n    @overload\n    def __get_data__(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"Return default value if the data doesn't contain key.\"\"\"\n\n    def __get_data__(self, __key: str, __default: Any = None):\n        if __key in self._unopened_keys:\n            self._load_from_h5(key=__key)\n        data = self._data.get(__key, __default)\n        if isinstance(data, NotLoaded):\n            self._load_from_h5(key=__key)\n            data = self._data.get(__key, __default)\n        if self.__check_read_only_true(__key):\n            if hasattr(data, \"_read_only\"):\n                data._read_only = True  # type: ignore # pylint: disable=protected-access\n            else:\n                data = deepcopy(data)\n        return data\n\n    def __get_data_or_raise__(self, __key):\n        # self.pull(auto=True)\n        if __key in self._unopened_keys:\n            self._load_from_h5(key=__key)\n        data = self._data.__getitem__(__key)\n        if isinstance(data, NotLoaded):\n            self._load_from_h5(key=__key)\n            data = self._data.__getitem__(__key)\n        if self.__check_read_only_true(__key):\n            if hasattr(data, \"_read_only\"):\n                data._read_only = True  # type: ignore # pylint: disable=protected-access\n            else:\n                data = deepcopy(data)\n        return data\n\n    def __set_data__(self, __key: str, __value):\n        # self.pull(auto=True)\n        return self._data.__setitem__(__key, __value)\n\n    def items(self):\n        \"\"\"Return all items in the collection.\n\n        It opens all items that were not opened yet and return dictionary iterator.\n        \"\"\"\n        if self._unopened_keys:\n            self._load_from_h5(key=self._unopened_keys)\n        return self._data.items()\n\n    def values(self):\n        \"\"\"Return all values in the collection.\n\n        It opens all items that were not opened yet and return dictionary iterator.\n        \"\"\"\n        # self.pull(auto=True)\n        if self._unopened_keys:\n            self._load_from_h5(key=self._unopened_keys)\n        return self._data.values()\n\n    def keys(self) -&gt; Set[str]:\n        \"\"\"Return all keys in the collection.\"\"\"\n        # self.pull(auto=True)\n        return self._keys.copy().union(self._unopened_keys.copy())\n\n    def keys_tree(self) -&gt; Dict[str, Optional[dict]]:\n        \"\"\"Return dict of the keys, where value always is a dict or None.\n\n        Examples:\n            ```\n            &gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n            &gt;&gt;&gt; sd.keys_tree()\n            {'a': {'b': None}, 'c': None}\n            ```\n\n        For all unopened keys, it does not open them and does not explore the structure.\n        \"\"\"\n        structure = get_keys_structure(self._data)\n\n        for key in self._unopened_keys:\n            structure[key] = None\n        return structure\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def _get_repr(self):\n        if self._repr is None:\n            additional_info = (\n                {key: \" (r)\" for key in self._read_only}\n                if isinstance(self._read_only, set)\n                else None\n            )\n            self._repr = output_dict_structure(\n                self._data, additional_info=additional_info\n            ) + (\n                f\"\\nUnloaded keys: {self._unopened_keys}\" if self._unopened_keys else \"\"\n            )\n\n    def __repr__(self):\n        self._get_repr()\n\n        not_saved = (\n            \"\" if self._last_data_saved or self._read_only is True else \" (not saved)\"\n        )\n        mode = (\n            \"r\"\n            if self._read_only is True\n            else \"w\" if self._read_only is False else \"rw\"\n        )\n        mode = \"l\" if self._filepath is None and self._read_only is not True else mode\n        not_saved = \"\" if mode == \"l\" else not_saved\n\n        return f\"{type(self).__name__} ({mode}){not_saved}: \\n {self._repr}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __contains__(self, item):\n        return (item in self._data) or (item in self._unopened_keys)\n\n    def __dir__(self) -&gt; Iterable[str]:\n        return list(self._keys) + self._default_attr\n\n    def __similar__(self, other: \"DH5\") -&gt; bool:\n        \"\"\"Check if 2 DH5 are similar.\n\n        It means: same file, mode, save_on_edit. Does not check the data.\n        \"\"\"\n        return (\n            self._filepath == other._filepath  # pylint: disable=protected-access\n            and self._read_only == other._read_only  # pylint: disable=protected-access\n            and self._save_on_edit\n            == other._save_on_edit  # pylint: disable=protected-access\n            and self.__should_initialized\n            == other.__should_initialized  # pylint: disable=protected-access\n        )\n\n    def _pre_save(self, *args, **kwargs):\n        del args, kwargs\n        if self.__should_initialized and self._filepath:\n            os.remove(self._filepath)\n            self.__should_initialized = False\n\n    def save(\n        self,\n        only_update: Union[bool, Iterable[str]] = True,\n        filepath: Optional[str] = None,\n        force: Optional[bool] = None,\n    ):\n        \"\"\"Save the data to a file.\n\n        Args:\n            only_update (Union[bool, Iterable[str]], optional): Determines whether to save only\n                the updated data or all data.\n                If True, only the updated data will be saved. If False, all data will be saved.\n                If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.\n            filepath (str, optional): The path to the file where the data will be saved.\n                If not provided, the default filepath will be used. Defaults to None.\n            force (bool, optional): Determines whether to force the save operation, even if only_update is True.\n                If True, the save operation will be forced. If False or None, the save operation\n                will be performed according to the value of only_update. Defaults to None.\n\n        Returns:\n            self\n\n        Raises:\n            ValueError: If the file is opened in read-only mode, it cannot be saved.\n                The file should be reopened in write mode before saving.\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\n                \"Cannot save opened in a read-only mode. Should reopen the file\"\n            )\n\n        self._pre_save()\n\n        if force is True or filepath is not None:\n            only_update = False\n\n        if isinstance(only_update, Iterable):\n            last_update = self._last_update.intersection(only_update)\n            self._last_update = self._last_update.difference(only_update)\n        else:\n            last_update, self._last_update = self._last_update, set()\n\n        if len(self._last_update) == 0:\n            self._last_data_saved = True\n\n        filepath = self._check_if_filepath_was_set(filepath, self._filepath)\n\n        if only_update is False:\n            if self._read_only is False:\n                data_to_save = self._data\n            else:\n                data_to_save = {\n                    key: value\n                    for key, value in self._data.items()\n                    if key not in self._read_only or key in last_update\n                }\n            data_to_save.update(\n                {\n                    key: None\n                    for key in last_update\n                    if (key not in self._data) and not self.__check_read_only_true(key)\n                }\n            )\n\n            self.__h5py_utils_save_dict_with_retry(filepath=filepath, data=data_to_save)\n\n            return self\n\n        for key in last_update:\n            if key in self._classes_should_be_saved_internally:\n                obj = self._data[key]\n                if hasattr(obj, \"save\"):\n                    self._data[key].save(only_update=only_update)\n                else:\n                    self._classes_should_be_saved_internally.remove(key)\n\n        self.__h5py_utils_save_dict_with_retry(\n            filepath=filepath,\n            data={\n                key: self._data.get(key)\n                for key in last_update\n                if key not in self._classes_should_be_saved_internally\n            },\n        )\n\n        return self\n\n    def __h5py_utils_save_dict_with_retry(self, filepath: str, data: dict):\n        # print(\"open\", time.time(), self._raise_file_locked_error)\n        for i in range(self._retry_on_file_locked_error):\n            try:\n                # print(\"_raise_file_locked_error\", self._raise_file_locked_error, list(data.keys()))\n                self._file_modified_time = h5py_utils.save_dict(\n                    filename=filepath + \".h5\", data=data, key_prefix=self._key_prefix\n                )\n                return\n            except h5py_utils.FileLockedError as error:\n                if self._raise_file_locked_error:\n                    raise error\n                logging.info(\"File is locked. waiting 2s and %d more retrying.\", i)\n                from ..utils import async_utils\n\n                async_utils.sleep(1)\n\n        raise h5py_utils.FileLockedError(\n            f\"Even after {self._retry_on_file_locked_error} data was not saved\"\n        )\n\n    @staticmethod\n    def _check_if_filepath_was_set(\n        filepath: Optional[str], filepath2: Optional[str]\n    ) -&gt; str:\n        \"\"\"Return path to the file with filename, but without extension.\"\"\"\n        filepath = filepath or filepath2\n        if filepath is None:\n            raise ValueError(\n                \"Should provide filepath or set self.filepath before saving\"\n            )\n        filepath = (\n            (filepath.rsplit(\".h5\", 1)[0]) if filepath.endswith(\".h5\") else filepath\n        )\n        return filepath\n\n    @property\n    def filepath(self):\n        \"\"\"Return the filepath without the '.h5' extension.\n\n        If the filepath is None, returns None.\n        \"\"\"\n        return None if self._filepath is None else (self._filepath.rsplit(\".h5\", 1)[0])\n\n    @filepath.setter\n    def filepath(self, value: str):\n        if not isinstance(value, str):\n            value = str(value)\n        self._filepath = value if value.endswith(\".h5\") else value + \".h5\"\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Return the filename of the current filepath without '.h5' extension.\n\n        Returns:\n            Optional[str]: The filename of the current filepath, or None if the filepath is None.\n        \"\"\"\n        filepath = self.filepath\n        if filepath is None:\n            return None\n        return os.path.basename(filepath)\n\n    @property\n    def save_on_edit(self):\n        \"\"\"Return the current value of the save_on_edit attribute.\"\"\"\n        return self._save_on_edit\n\n    def asdict(self):\n        \"\"\"Return the internal data of the object as a dictionary.\n\n        Returns:\n            dict: A dictionary representation of the object's internal data.\n        \"\"\"\n        return self._data\n\n    def pull_available(self):\n        \"\"\"Check if the file has been modified elsewhere since the last save.\n\n        Raises:\n            ValueError: If the filepath has not been set.\n\n        Returns:\n            bool: True if the file has been modified, False otherwise.\n        \"\"\"\n        if self.filepath is None:\n            raise ValueError(\"Cannot pull from file if it's not been set\")\n        file_modified = os.path.getmtime(self.filepath + \".h5\")\n        return self._file_modified_time != file_modified\n\n    def pull(self, force_pull: bool = False):\n        \"\"\"Pull data from a file and reloads it into the object.\n\n        Args:\n            force_pull (bool, optional): If True, forces to update data even if the file\n            has not been modified. Defaults to False.\n\n        Raises:\n            ValueError: If the filepath has not been set.\n\n        Returns:\n            self: The updated object.\n        \"\"\"\n        if self.filepath is None:\n            raise ValueError(\"Cannot pull from file if it's not been set\")\n\n        if force_pull or self.pull_available():\n            logging.debug(\"File modified so it will be reloaded.\")\n            self._data = {}\n            self._keys = set()\n            self._clean_precalculated_results()\n            self._load_from_h5()\n\n        return self\n\n    @overload\n    def close_data(self, key: None = None, every: Literal[True] = True):\n        \"\"\"Close every opened key so it could be collected by the garbage collector afterwards.\"\"\"\n\n    @overload\n    def close_data(self, key: Iterable[str]):\n        \"\"\"Close every key provided so it could be collected by the garbage collector afterwards.\"\"\"\n\n    @overload\n    def close_data(self, key: str):  # type: ignore\n        \"\"\"Close the key so it could be collected by the garbage collector afterwards.\"\"\"\n\n    def close_data(\n        self,\n        key: Optional[Union[str, Iterable[str]]] = None,\n        every: Optional[Literal[True]] = None,\n    ):\n        \"\"\"Close the key so it could be collected by the garbage collector afterwards.\n\n        Args:\n            key (str | Iterable[str], optional): key or keys that should be closed. Defaults to None.\n            every (True, optional): put to True if all keys should be closed. Defaults to None.\n\n        Raises:\n            ValueError: if both key and every are not provided.\n\n        Returns:\n            Self.\n        \"\"\"\n        if every is True:\n            for k in self.keys():\n                self.close_data(k)\n            return self\n        elif key is None:\n            raise ValueError(\"Should provide key or every=True.\")\n\n        if not isinstance(key, str):\n            for k in key:\n                self.close_data(k)\n            return self\n\n        if key not in self._unopened_keys:\n            self._data.pop(key)\n        self._unopened_keys.add(key)\n\n        return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.filename","title":"filename  <code>property</code>","text":"<pre><code>filename\n</code></pre> <p>Return the filename of the current filepath without '.h5' extension.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The filename of the current filepath, or None if the filepath is None.</p>"},{"location":"dh5/#dh5.DH5.filepath","title":"filepath  <code>property</code> <code>writable</code>","text":"<pre><code>filepath\n</code></pre> <p>Return the filepath without the '.h5' extension.</p> <p>If the filepath is None, returns None.</p>"},{"location":"dh5/#dh5.DH5.save_on_edit","title":"save_on_edit  <code>property</code>","text":"<pre><code>save_on_edit\n</code></pre> <p>Return the current value of the save_on_edit attribute.</p>"},{"location":"dh5/#dh5.DH5.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(__key)\n</code></pre> <p>Return raw value associated with the given key.</p> <p>Same as <code>get_raw</code> but raises error if the key is not found.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | tuple</code> <p>The key to retrieve the dictionary for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Raw value without any conversion.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def __getitem__(self, __key: Union[str, tuple]) -&gt; Any:\n    \"\"\"Return raw value associated with the given key.\n\n    Same as `get_raw` but raises error if the key is not found.\n\n    Args:\n        key (str | tuple): The key to retrieve the dictionary for.\n\n    Returns:\n        Raw value without any conversion.\n\n    Raises:\n        KeyError: If the key is not found.\n\n    \"\"\"\n    if isinstance(__key, tuple):\n        if len(__key) &gt; 1:\n            return self.__getitem__(__key[0]).__getitem__(\n                __key[1:] if len(__key) &gt; 2 else __key[1]\n            )\n        if len(__key) == 1:\n            return self.__getitem__(__key[0])\n        raise ValueError(\n            \"Key should be a string or tuple with at least one element\"\n        )\n    return self.__get_data_or_raise__(__key)\n</code></pre>"},{"location":"dh5/#dh5.DH5.__init__","title":"__init__","text":"<pre><code>__init__(filepath_or_data=None, /, mode=None, *, filepath=None, save_on_edit=False, read_only=None, overwrite=None, data=None, open_on_init=None, **kwds)\n</code></pre> <p>DH5.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_data</code> <code>str | dict</code> <p>either filepath, either data as dict.</p> <code>None</code> <code>filepath</code> <code>str | Path</code> <p>filepath to load. Defaults to None.</p> <code>None</code> <code>save_on_edit</code> <code>bool</code> <p>Save data as soon as you changed it. Defaults to False. And data should be saved using <code>save()</code> method.</p> <code>False</code> <code>read_only</code> <code>bool</code> <p>opens file in read_only mode, i.e. it cannot be modified. Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>If file exists, it should be explicitly precised. By default raises an error if file exist.</p> <code>None</code> <code>data</code> <code>Optional[dict]</code> <p>Data to load. If data provided, file . Defaults to None.</p> <code>None</code> <code>open_on_init</code> <code>Optional[bool]</code> <p>open_on_init. Defaults to True.</p> <code>None</code> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def __init__(\n    self,\n    filepath_or_data: Optional[Union[str, dict, Path]] = None,\n    /,\n    mode: Optional[Literal[\"r\", \"w\", \"a\", \"w=\", \"a=\"]] = None,\n    *,\n    filepath: Optional[Union[str, Path]] = None,\n    save_on_edit: bool = False,\n    read_only: Optional[Union[bool, Set[str]]] = None,\n    overwrite: Optional[bool] = None,\n    data: Optional[dict] = None,\n    open_on_init: Optional[bool] = None,\n    **kwds,\n):\n    \"\"\"DH5.\n\n    Args:\n        filepath_or_data (str|dict, optional): either filepath, either data as dict.\n        filepath (str|Path, optional): filepath to load. Defaults to None.\n        save_on_edit (bool, optional): Save data as soon as you changed it.\n            Defaults to False. And data should be saved using `save()` method.\n        read_only (bool, optional): opens file in read_only mode, i.e. it cannot be modified.\n            Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.\n        overwrite (Optional[bool], optional):\n            If file exists, it should be explicitly precised.\n            By default raises an error if file exist.\n        data (Optional[dict], optional):\n            Data to load. If data provided, file . Defaults to None.\n        open_on_init (Optional[bool], optional): open_on_init. Defaults to True.\n\n    \"\"\"\n    if mode is not None:\n        if mode.startswith(\"w\"):\n            read_only = False\n        elif mode.startswith(\"a\"):\n            read_only = False\n            overwrite = False\n        elif mode == \"r\":\n            read_only = True\n        if mode.endswith(\"=\"):\n            save_on_edit = True\n\n    if filepath_or_data is not None and hasattr(filepath_or_data, \"keys\"):\n        if not isinstance(filepath_or_data, dict):\n            filepath_or_data = {key: filepath_or_data[key] for key in filepath_or_data.keys()}  # type: ignore\n        data = data or filepath_or_data\n\n    if isinstance(filepath_or_data, (str, Path)):\n        filepath = filepath or filepath_or_data\n\n    if filepath and not isinstance(filepath, str):\n        filepath = str(filepath)\n\n    self._data: Dict[str, Any] = data or {}\n    # transform_to_possible_formats(self._data)\n    self._keys: Set[str] = set(self._data.keys())\n    self._last_update = set()\n    self._save_on_edit = save_on_edit\n    self._classes_should_be_saved_internally = set()\n    self._key_prefix: Optional[str] = kwds.get(\"key_prefix\")\n\n    if read_only is None:\n        read_only = (\n            save_on_edit is False and not overwrite\n        ) and filepath is not None\n\n    if open_on_init is False and overwrite is True:\n        raise ValueError(\"Cannot overwrite file and open_on_init=False mode\")\n    self._open_on_init = (\n        open_on_init if open_on_init is not None else (None if self._data else True)\n    )\n    self._unopened_keys = set()\n\n    # if keep_up_to_data and read_only is True:\n    # raise ValueError(\"Cannot open file in read-only and keep_up_to_data=True mode\")\n    # self._keep_up_to_data = keep_up_to_data\n\n    self._read_only = read_only\n    if filepath is not None:\n        filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n\n        if (overwrite or save_on_edit) and read_only:\n            raise ValueError(\n                \"\"\"Cannot open file in read_only mode and overwrite it.\"\"\"\n            )\n\n        if os.path.exists(filepath):\n            if overwrite is None and not read_only:\n                raise FileExistsError(\n                    \"File with the same name already exists. So you should explicitly \"\n                    \"provide what to do with it. Set `overwrite=True` to replace file. \"\n                    \"Set `overwrite=False` if you want to open existing file and work with it.\"\n                )\n\n            if overwrite and not read_only:\n                self.__should_initialized = True\n                # os.remove(filepath)\n\n            if read_only or (not read_only and not overwrite):\n                if self._open_on_init:\n                    self._load_from_h5(filepath)\n                elif self._open_on_init is False:\n                    self._keys = h5py_utils.keys_h5(\n                        filepath, key_prefix=self._key_prefix\n                    )\n                    self._unopened_keys.update(self._keys)\n\n        elif read_only:\n            raise ValueError(\n                f\"Cannot open file in read_only mode if file {filepath} does not exist\"\n            )\n\n        # if not read_only:\n        self._filepath = filepath\n</code></pre>"},{"location":"dh5/#dh5.DH5.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(__key, __value)\n</code></pre> <p>Set value corresponding to the given key.</p> <p>See <code>DH5.data_transformation</code> to learn more     about how the types are converted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | tuple</code> <p>The key to retrieve the dictionary for.</p> required Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef __setitem__(\n    self, __key: Union[str, tuple], __value: \"DICT_OR_LIST_LIKE\"\n) -&gt; None:\n    \"\"\"Set value corresponding to the given key.\n\n    See [`DH5.data_transformation`](data_transformation.md) to learn more\n        about how the types are converted.\n\n    Args:\n        key (str | tuple): The key to retrieve the dictionary for.\n\n    \"\"\"\n    if isinstance(__key, tuple):\n        if not __key or len(__key) == 1 or len(__key) == 0:\n            raise ValueError(\n                \"Key should be a string or tuple with at least two elements\"\n            )\n\n        self.__add_key(__key[0])\n        if self.__check_read_only_true(__key[0]):\n            raise ReadOnlyKeyError(__key[0], action=\"set\")\n        return self.__getitem__(__key[0]).__setitem__(\n            __key[1:] if len(__key) &gt; 2 else __key[1], __value  # type: ignore\n        )\n\n    if self.__check_read_only_true(__key):\n        raise ReadOnlyKeyError(__key, action=\"set\")\n\n    self.__add_key(__key)\n    __value = transform_to_possible_formats(__value)\n\n    if self._read_only is not True:\n        if hasattr(__value, \"save\"):\n            self._classes_should_be_saved_internally.add(__key)\n\n        if hasattr(__value, \"__init__filepath__\") and self._filepath:\n            key = (\n                __key if self._key_prefix is None else f\"{self._key_prefix}/{__key}\"\n            )\n            __value.__init__filepath__(  # type: ignore\n                filepath=self._filepath,\n                filekey=key,\n                save_on_edit=self._save_on_edit,\n            )\n\n        if hasattr(__value, \"__post__init__\"):\n            __value.__post__init__()  # type: ignore\n\n    self.__set_data__(__key, __value)\n    return None\n</code></pre>"},{"location":"dh5/#dh5.DH5.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Return the internal data of the object as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the object's internal data.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def asdict(self):\n    \"\"\"Return the internal data of the object as a dictionary.\n\n    Returns:\n        dict: A dictionary representation of the object's internal data.\n    \"\"\"\n    return self._data\n</code></pre>"},{"location":"dh5/#dh5.DH5.close_data","title":"close_data","text":"<pre><code>close_data(key=None, every=None)\n</code></pre> <p>Close the key so it could be collected by the garbage collector afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Iterable[str]</code> <p>key or keys that should be closed. Defaults to None.</p> <code>None</code> <code>every</code> <code>True</code> <p>put to True if all keys should be closed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if both key and every are not provided.</p> <p>Returns:</p> Type Description <p>Self.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def close_data(\n    self,\n    key: Optional[Union[str, Iterable[str]]] = None,\n    every: Optional[Literal[True]] = None,\n):\n    \"\"\"Close the key so it could be collected by the garbage collector afterwards.\n\n    Args:\n        key (str | Iterable[str], optional): key or keys that should be closed. Defaults to None.\n        every (True, optional): put to True if all keys should be closed. Defaults to None.\n\n    Raises:\n        ValueError: if both key and every are not provided.\n\n    Returns:\n        Self.\n    \"\"\"\n    if every is True:\n        for k in self.keys():\n            self.close_data(k)\n        return self\n    elif key is None:\n        raise ValueError(\"Should provide key or every=True.\")\n\n    if not isinstance(key, str):\n        for k in key:\n            self.close_data(k)\n        return self\n\n    if key not in self._unopened_keys:\n        self._data.pop(key)\n    self._unopened_keys.add(key)\n\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Retrieve the value associated with the given key from the DH5 object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key to be searched.</p> required <code>default</code> <code>Any</code> <p>Value to be returned if the <code>key</code> is not found. The default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key. If the value is a dict then it's converter</p> <code>Any</code> <p>into <code>DH5</code> object. This conversion take some time, but allow to change, save and</p> <code>Any</code> <p>this sub-object. For faster performance use <code>get_raw</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n&gt;&gt;&gt; sync_data.get('name')\n'John'\n&gt;&gt;&gt; sync_data.get('surname')\nNone\n&gt;&gt;&gt; sync_data.get('gender', 'unknown')\n'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieve the value associated with the given key from the DH5 object.\n\n    Args:\n        key (str): Key to be searched.\n        default (Any, optional): Value to be returned if the `key` is not found.\n            The default value is `None`.\n\n    Returns:\n        The value associated with the key. If the value is a dict then it's converter\n        into `DH5` object. This conversion take some time, but allow to change, save and\n        this sub-object. For faster performance use `get_raw` method.\n\n    Examples:\n        &gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n        &gt;&gt;&gt; sync_data.get('name')\n        'John'\n        &gt;&gt;&gt; sync_data.get('surname')\n        None\n        &gt;&gt;&gt; sync_data.get('gender', 'unknown')\n        'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n\n    \"\"\"\n    data = self.__get_data__(key, default)\n    if isinstance(data, dict) and data:\n        return DH5(\n            filepath=self._filepath,\n            data=data,\n            overwrite=False,\n            key_prefix=key,\n            read_only=self.__check_read_only_true(key),\n        )\n    return data\n</code></pre>"},{"location":"dh5/#dh5.DH5.get_raw","title":"get_raw","text":"<pre><code>get_raw(key, default=None)\n</code></pre> <p>Return raw value associated with the given key.</p> <p>Dictionaries are not converted to the <code>DH5</code> unlike <code>get</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key to be searched.</p> required <code>default</code> <code>Any</code> <p>Value to be returned if the <code>key</code> is not found. The default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Raw value without any conversion or the default value if the key is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n&gt;&gt;&gt; sync_data.get_raw('key1')\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; sync_data.get_raw('key2')\n5\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def get_raw(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Return raw value associated with the given key.\n\n    Dictionaries are not converted to the `DH5` unlike `get` method.\n\n    Args:\n        key (str): Key to be searched.\n        default (Any, optional): Value to be returned if the `key` is not found.\n            The default value is `None`.\n\n\n    Returns:\n        Raw value without any conversion or the default value if the key is not found.\n\n    Examples:\n        &gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n        &gt;&gt;&gt; sync_data.get_raw('key1')\n        {'a': 1, 'b': 2}\n        &gt;&gt;&gt; sync_data.get_raw('key2')\n        5\n    \"\"\"\n    return self.__get_data__(key, default)\n</code></pre>"},{"location":"dh5/#dh5.DH5.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return all items in the collection.</p> <p>It opens all items that were not opened yet and return dictionary iterator.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def items(self):\n    \"\"\"Return all items in the collection.\n\n    It opens all items that were not opened yet and return dictionary iterator.\n    \"\"\"\n    if self._unopened_keys:\n        self._load_from_h5(key=self._unopened_keys)\n    return self._data.items()\n</code></pre>"},{"location":"dh5/#dh5.DH5.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return all keys in the collection.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def keys(self) -&gt; Set[str]:\n    \"\"\"Return all keys in the collection.\"\"\"\n    # self.pull(auto=True)\n    return self._keys.copy().union(self._unopened_keys.copy())\n</code></pre>"},{"location":"dh5/#dh5.DH5.keys_tree","title":"keys_tree","text":"<pre><code>keys_tree()\n</code></pre> <p>Return dict of the keys, where value always is a dict or None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n&gt;&gt;&gt; sd.keys_tree()\n{'a': {'b': None}, 'c': None}\n</code></pre> <p>For all unopened keys, it does not open them and does not explore the structure.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def keys_tree(self) -&gt; Dict[str, Optional[dict]]:\n    \"\"\"Return dict of the keys, where value always is a dict or None.\n\n    Examples:\n        ```\n        &gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n        &gt;&gt;&gt; sd.keys_tree()\n        {'a': {'b': None}, 'c': None}\n        ```\n\n    For all unopened keys, it does not open them and does not explore the structure.\n    \"\"\"\n    structure = get_keys_structure(self._data)\n\n    for key in self._unopened_keys:\n        structure[key] = None\n    return structure\n</code></pre>"},{"location":"dh5/#dh5.DH5.load","title":"load","text":"<pre><code>load(filepath=None, key=None)\n</code></pre> <p>Load data from h5 into current object.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def load(\n    self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n):\n    \"\"\"Load data from h5 into current object.\"\"\"\n    updated_from_other_file = filepath is not None\n    updated_key = self._load_from_h5(filepath=filepath, key=key)\n    if updated_from_other_file:\n        for key in updated_key:\n            self._keys.add(key)\n\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.lock_data","title":"lock_data","text":"<pre><code>lock_data(keys=None)\n</code></pre> <p>Locks the specified keys in the database so they cannot be changed.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Optional[Iterable[str]]</code> <p>An optional iterable of strings representing the keys to be locked.</p> <code>None</code> <p>Returns:</p> Type Description <code>_SELF</code> <p>A reference to the DH5 object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If everything is already locked by read_only mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n&gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n&gt;&gt;&gt; sd['key1'] = 2\nReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n&gt;&gt;&gt; sd['key2'] = 5\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def lock_data(self: _SELF, keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n    \"\"\"Locks the specified keys in the database so they cannot be changed.\n\n    Args:\n        keys: An optional iterable of strings representing the keys to be locked.\n        If None, all keys will be locked.\n\n    Returns:\n        A reference to the DH5 object.\n\n    Raises:\n        ValueError: If everything is already locked by read_only mode.\n\n    Examples:\n        &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n        &gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n        &gt;&gt;&gt; sd['key1'] = 2\n        ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n        &gt;&gt;&gt; sd['key2'] = 5\n\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\n            \"Cannot lock specific data and everything is locked by read_only mode\"\n        )\n    if not isinstance(self._read_only, set):\n        self._read_only = set()\n    if keys is None:\n        keys = self.keys()\n    elif isinstance(keys, str):\n        keys = (keys,)\n\n    for key in keys:\n        self._read_only.add(key)\n\n    self._clean_precalculated_results()\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.open_overwrite","title":"open_overwrite  <code>classmethod</code>","text":"<pre><code>open_overwrite(filepath_or_data=None, /, mode=None, *, filepath=None, save_on_edit=False, read_only=None, overwrite=True, data=None, open_on_init=None, **kwds)\n</code></pre> <p>Open file in the overwrite mode.</p> <p>It deletes the file if it exists and then opens it in the write mode. Same syntax as <code>__init__</code> method.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@classmethod\ndef open_overwrite(\n    cls,\n    filepath_or_data: Optional[Union[str, dict, Path]] = None,\n    /,\n    mode: Optional[Literal[\"=\"]] = None,\n    *,\n    filepath: Optional[Union[str, Path]] = None,\n    save_on_edit: bool = False,\n    read_only: Optional[Union[bool, Set[str]]] = None,\n    overwrite: Optional[bool] = True,\n    data: Optional[dict] = None,\n    open_on_init: Optional[bool] = None,\n    **kwds,\n):\n    \"\"\"Open file in the overwrite mode.\n\n    It deletes the file if it exists and then opens it in the write mode.\n    Same syntax as `__init__` method.\n    \"\"\"\n    mode_ = \"w=\" if mode == \"=\" else \"w\"\n    return cls(\n        filepath_or_data,\n        mode=mode_,\n        filepath=filepath,\n        save_on_edit=save_on_edit,\n        read_only=read_only,\n        overwrite=overwrite,\n        data=data,\n        open_on_init=open_on_init,\n        **kwds,\n    )\n</code></pre>"},{"location":"dh5/#dh5.DH5.pop","title":"pop","text":"<pre><code>pop(key)\n</code></pre> <p>Remove the specified key and return the value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Union[Any, NotLoaded]</code> <p>Same as <code>get</code> method, i.e. <code>DH5</code> if the value is a dict otherwise the value. If data was never loaded it will return <code>NotLoaded</code>. To load data use <code>get</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; data.pop('b')\n2\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef pop(self, key: str) -&gt; Union[Any, NotLoaded]:\n    \"\"\"Remove the specified key and return the value.\n\n    Args:\n        key (str): The key to remove.\n\n    Returns:\n        Same as `get` method, i.e. `DH5` if the value is a dict otherwise the value.\n            If data was never loaded it will return `NotLoaded`. To load data use `get` method.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n        &gt;&gt;&gt; data.pop('b')\n        2\n\n    \"\"\"\n    if self.__check_read_only_true(key):\n        raise ReadOnlyKeyError(key, action=\"pop\")\n    self.__del_key(key)\n    # self.pull(auto=True)\n    if key not in self._unopened_keys:\n        return self._data.pop(key)\n    return NotLoaded()\n</code></pre>"},{"location":"dh5/#dh5.DH5.pull","title":"pull","text":"<pre><code>pull(force_pull=False)\n</code></pre> <p>Pull data from a file and reloads it into the object.</p> <p>Parameters:</p> Name Type Description Default <code>force_pull</code> <code>bool</code> <p>If True, forces to update data even if the file</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the filepath has not been set.</p> <p>Returns:</p> Name Type Description <code>self</code> <p>The updated object.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def pull(self, force_pull: bool = False):\n    \"\"\"Pull data from a file and reloads it into the object.\n\n    Args:\n        force_pull (bool, optional): If True, forces to update data even if the file\n        has not been modified. Defaults to False.\n\n    Raises:\n        ValueError: If the filepath has not been set.\n\n    Returns:\n        self: The updated object.\n    \"\"\"\n    if self.filepath is None:\n        raise ValueError(\"Cannot pull from file if it's not been set\")\n\n    if force_pull or self.pull_available():\n        logging.debug(\"File modified so it will be reloaded.\")\n        self._data = {}\n        self._keys = set()\n        self._clean_precalculated_results()\n        self._load_from_h5()\n\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.pull_available","title":"pull_available","text":"<pre><code>pull_available()\n</code></pre> <p>Check if the file has been modified elsewhere since the last save.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the filepath has not been set.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the file has been modified, False otherwise.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def pull_available(self):\n    \"\"\"Check if the file has been modified elsewhere since the last save.\n\n    Raises:\n        ValueError: If the filepath has not been set.\n\n    Returns:\n        bool: True if the file has been modified, False otherwise.\n    \"\"\"\n    if self.filepath is None:\n        raise ValueError(\"Cannot pull from file if it's not been set\")\n    file_modified = os.path.getmtime(self.filepath + \".h5\")\n    return self._file_modified_time != file_modified\n</code></pre>"},{"location":"dh5/#dh5.DH5.remove","title":"remove","text":"<pre><code>remove(key)\n</code></pre> <p>Remove the specified key and self.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>_SELF</code> <p>Self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; data.pop('b')\nDH5({'a': 1, 'c': 3})\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef remove(self: _SELF, key: str) -&gt; _SELF:\n    \"\"\"Remove the specified key and self.\n\n    Args:\n        key (str): The key to remove.\n\n    Returns:\n        Self.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n        &gt;&gt;&gt; data.pop('b')\n        DH5({'a': 1, 'c': 3})\n\n    \"\"\"\n    self.pop(key)\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.save","title":"save","text":"<pre><code>save(only_update=True, filepath=None, force=None)\n</code></pre> <p>Save the data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>only_update</code> <code>Union[bool, Iterable[str]]</code> <p>Determines whether to save only the updated data or all data. If True, only the updated data will be saved. If False, all data will be saved. If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.</p> <code>True</code> <code>filepath</code> <code>str</code> <p>The path to the file where the data will be saved. If not provided, the default filepath will be used. Defaults to None.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to force the save operation, even if only_update is True. If True, the save operation will be forced. If False or None, the save operation will be performed according to the value of only_update. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>self</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is opened in read-only mode, it cannot be saved. The file should be reopened in write mode before saving.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def save(\n    self,\n    only_update: Union[bool, Iterable[str]] = True,\n    filepath: Optional[str] = None,\n    force: Optional[bool] = None,\n):\n    \"\"\"Save the data to a file.\n\n    Args:\n        only_update (Union[bool, Iterable[str]], optional): Determines whether to save only\n            the updated data or all data.\n            If True, only the updated data will be saved. If False, all data will be saved.\n            If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.\n        filepath (str, optional): The path to the file where the data will be saved.\n            If not provided, the default filepath will be used. Defaults to None.\n        force (bool, optional): Determines whether to force the save operation, even if only_update is True.\n            If True, the save operation will be forced. If False or None, the save operation\n            will be performed according to the value of only_update. Defaults to None.\n\n    Returns:\n        self\n\n    Raises:\n        ValueError: If the file is opened in read-only mode, it cannot be saved.\n            The file should be reopened in write mode before saving.\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\n            \"Cannot save opened in a read-only mode. Should reopen the file\"\n        )\n\n    self._pre_save()\n\n    if force is True or filepath is not None:\n        only_update = False\n\n    if isinstance(only_update, Iterable):\n        last_update = self._last_update.intersection(only_update)\n        self._last_update = self._last_update.difference(only_update)\n    else:\n        last_update, self._last_update = self._last_update, set()\n\n    if len(self._last_update) == 0:\n        self._last_data_saved = True\n\n    filepath = self._check_if_filepath_was_set(filepath, self._filepath)\n\n    if only_update is False:\n        if self._read_only is False:\n            data_to_save = self._data\n        else:\n            data_to_save = {\n                key: value\n                for key, value in self._data.items()\n                if key not in self._read_only or key in last_update\n            }\n        data_to_save.update(\n            {\n                key: None\n                for key in last_update\n                if (key not in self._data) and not self.__check_read_only_true(key)\n            }\n        )\n\n        self.__h5py_utils_save_dict_with_retry(filepath=filepath, data=data_to_save)\n\n        return self\n\n    for key in last_update:\n        if key in self._classes_should_be_saved_internally:\n            obj = self._data[key]\n            if hasattr(obj, \"save\"):\n                self._data[key].save(only_update=only_update)\n            else:\n                self._classes_should_be_saved_internally.remove(key)\n\n    self.__h5py_utils_save_dict_with_retry(\n        filepath=filepath,\n        data={\n            key: self._data.get(key)\n            for key in last_update\n            if key not in self._classes_should_be_saved_internally\n        },\n    )\n\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.unlock_data","title":"unlock_data","text":"<pre><code>unlock_data(remove_keys=None)\n</code></pre> <p>Unlock the specified keys in the database so they can be changed.</p> <p>If file was opened in read-only mode you cannot unlock it, however you can open it again in 'a' mode and lock all keys except necessary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <p>An optional iterable of strings representing the keys to be unlocked.</p> required <p>Returns:</p> Type Description <code>_SELF</code> <p>A reference to the DH5 object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If everything is already locked by read_only mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n&gt;&gt;&gt; sd.lock_data()\n&gt;&gt;&gt; sd.unlock_data('key2')\n&gt;&gt;&gt; sd['key2'] = 5\n&gt;&gt;&gt; sd['key1'] = 2\nReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def unlock_data(self: _SELF, remove_keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n    \"\"\"Unlock the specified keys in the database so they can be changed.\n\n    If file was opened in read-only mode you cannot unlock it, however you can open\n    it again in 'a' mode and lock all keys except necessary.\n\n    Args:\n        keys: An optional iterable of strings representing the keys to be unlocked.\n        If None, all keys will be unlocked.\n\n    Returns:\n        A reference to the DH5 object.\n\n    Raises:\n        ValueError: If everything is already locked by read_only mode.\n\n    Examples:\n        &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n        &gt;&gt;&gt; sd.lock_data()\n        &gt;&gt;&gt; sd.unlock_data('key2')\n        &gt;&gt;&gt; sd['key2'] = 5\n        &gt;&gt;&gt; sd['key1'] = 2\n        ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\"Cannot unlock is global read_only mode was set to True\")\n    if isinstance(self._read_only, set):\n        if remove_keys is None:\n            self._read_only = False\n        else:\n            if isinstance(remove_keys, str):\n                remove_keys = (remove_keys,)\n            for key in remove_keys:\n                if key in self._read_only:\n                    self._read_only.remove(key)\n\n    self._clean_precalculated_results()\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.update","title":"update","text":"<pre><code>update(__m=None, **kwds)\n</code></pre> <p>Update data from a dictionary or keyword arguments.</p> <p>See <code>DH5.data_transformation</code> to learn more     about how the types are converted.</p> <p>Parameters:</p> Name Type Description Default <code>__m</code> <code>dict | None</code> <p>A dictionary of key-value pairs to update the DH5 object with.</p> <code>None</code> <code>**kwds</code> <code>DICT_OR_LIST_LIKE</code> <p>Keyword arguments of key-value pairs to update the DH5 object with.</p> <code>{}</code> <p>Returns:</p> Type Description <code>_SELF</code> <p>Self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5()\n&gt;&gt;&gt; data.update({'a': 1, 'b': 2})\nDH5({'a': 1, 'b': 2})\n&gt;&gt;&gt; data.update(c=3, d=4)\nDH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef update(\n    self: _SELF, __m: Optional[dict] = None, **kwds: \"DICT_OR_LIST_LIKE\"\n) -&gt; _SELF:\n    \"\"\"Update data from a dictionary or keyword arguments.\n\n    See `DH5.data_transformation` to learn more\n        about how the types are converted.\n\n    Args:\n        __m (dict | None): A dictionary of key-value pairs to update the DH5 object with.\n        **kwds (DICT_OR_LIST_LIKE): Keyword arguments of key-value pairs to update the DH5 object with.\n\n    Returns:\n        Self.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5()\n        &gt;&gt;&gt; data.update({'a': 1, 'b': 2})\n        DH5({'a': 1, 'b': 2})\n        &gt;&gt;&gt; data.update(c=3, d=4)\n        DH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n\n    \"\"\"\n    if __m is not None:\n        kwds.update(__m)\n\n    for key in kwds:  # pylint: disable=C0206\n        if self.__check_read_only_true(key):\n            raise ReadOnlyKeyError(key)\n        self.__add_key(key)\n        kwds[key] = transform_to_possible_formats(kwds[key])\n\n    # self.pull(auto=True)\n    self._data.update(**kwds)\n    return self\n</code></pre>"},{"location":"dh5/#dh5.DH5.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return all values in the collection.</p> <p>It opens all items that were not opened yet and return dictionary iterator.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def values(self):\n    \"\"\"Return all values in the collection.\n\n    It opens all items that were not opened yet and return dictionary iterator.\n    \"\"\"\n    # self.pull(auto=True)\n    if self._unopened_keys:\n        self._load_from_h5(key=self._unopened_keys)\n    return self._data.values()\n</code></pre>"},{"location":"dh5/h5_utils/","title":"H5 utils.","text":"<p>This module contains all necessary functions to work direct with h5 files</p> <p>Utils to save and load h5 files.</p>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.LockFile","title":"LockFile","text":"<p>Context manager that creates a lock file during writing to prevent conflicts.</p> Usage <p>To use the LockFile context manager, simply wrap your code that writes to a file with it. This will ensure that only one process can write to the file at a time.</p> Example <pre><code>with LockFile(\"data.txt\"):\n     # Code that writes to the file\n     with open(\"data.txt\", \"w\") as f:\n         pass\n</code></pre> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>class LockFile:\n    \"\"\"Context manager that creates a lock file during writing to prevent conflicts.\n\n    Usage:\n        To use the LockFile context manager, simply wrap your code that writes to a file with it.\n        This will ensure that only one process can write to the file at a time.\n\n    Example:\n        ```\n        with LockFile(\"data.txt\"):\n             # Code that writes to the file\n             with open(\"data.txt\", \"w\") as f:\n                 pass\n        ```\n\n    \"\"\"\n\n    def __init__(self, filename):\n        \"\"\"Initialize the LockFile object.\n\n        Args:\n            filename (str): The filename or filepath. Can end with an extension.\n        \"\"\"\n        self.lock_filename = os.path.splitext(filename)[0] + \".lock\"\n\n    def __enter__(self):\n        \"\"\"Enter the context and create the lock file.\"\"\"\n        if os.path.exists(self.lock_filename):\n            raise FileLockedError(\"File locked and cannot be opened in write mode\")\n        with open(self.lock_filename, \"w\", encoding=\"utf-8\"):\n            pass\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Exit the context and remove the lock file.\"\"\"\n        if os.path.exists(self.lock_filename):\n            os.remove(self.lock_filename)\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.LockFile.__init__","title":"__init__","text":"<pre><code>__init__(filename)\n</code></pre> <p>Initialize the LockFile object.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename or filepath. Can end with an extension.</p> required Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def __init__(self, filename):\n    \"\"\"Initialize the LockFile object.\n\n    Args:\n        filename (str): The filename or filepath. Can end with an extension.\n    \"\"\"\n    self.lock_filename = os.path.splitext(filename)[0] + \".lock\"\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.del_dict","title":"del_dict","text":"<pre><code>del_dict(filename, key, key_prefix=None)\n</code></pre> <p>Delete a key from an h5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Full filepath to the file.</p> required <code>key</code> <code>str</code> <p>The key to delete. If nested, use <code>key1/key2</code>.</p> required <code>key_prefix</code> <code>str</code> <p>If provided, the key prefix to use. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The time of the last modification of the file.</p> Example <pre><code>&gt;&gt;&gt; del_dict('/path/to/file.h5', 'key1', 'prefix')\n\"some_value\"\n</code></pre> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def del_dict(\n    filename: str,\n    key: str,\n    key_prefix: Optional[str] = None,\n) -&gt; float:\n    \"\"\"Delete a key from an h5 file.\n\n    Args:\n        filename (str): Full filepath to the file.\n        key (str): The key to delete. If nested, use `key1/key2`.\n        key_prefix (str, optional): If provided, the key prefix to use. Defaults to None.\n\n    Returns:\n        float: The time of the last modification of the file.\n\n    Example:\n        ```\n        &gt;&gt;&gt; del_dict('/path/to/file.h5', 'key1', 'prefix')\n        \"some_value\"\n        ```\n    \"\"\"\n    with LockFile(filename), h5py.File(filename, \"a\") as file:\n        key = key if key_prefix is None else f\"{key_prefix}/{key}\"\n        file.pop(key)\n    return os.path.getmtime(filename)\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.keys_h5","title":"keys_h5","text":"<pre><code>keys_h5(filename, key_prefix=None)\n</code></pre> <p>Return the keys of an h5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Full filepath to the h5 file.</p> required <code>key_prefix</code> <code>str</code> <p>Key prefix to look at. If nested, use <code>key1/key2</code>. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Set[str]</code> <p>Set[str]: Set of the keys in the h5 file.</p> Example <pre><code>&gt;&gt;&gt; keys_h5('/path/to/file.h5', 'group1')\n{'key1', 'key2', 'key3'}\n</code></pre> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def keys_h5(filename, key_prefix: Optional[str] = None) -&gt; Set[str]:\n    \"\"\"Return the keys of an h5 file.\n\n    Args:\n        filename (str): Full filepath to the h5 file.\n        key_prefix (str, optional): Key prefix to look at. If nested, use `key1/key2`.\n            Defaults to None.\n\n    Returns:\n        Set[str]: Set of the keys in the h5 file.\n\n    Example:\n        ```\n        &gt;&gt;&gt; keys_h5('/path/to/file.h5', 'group1')\n        {'key1', 'key2', 'key3'}\n        ```\n    \"\"\"\n    with h5py.File(filename, \"r\") as file:\n        if key_prefix is not None:\n            file = file[key_prefix]\n        return set(file.keys())  # type: ignore\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.open_h5","title":"open_h5","text":"<pre><code>open_h5(fullpath, key=None, key_prefix=None)\n</code></pre> <p>Open h5 file and return dict.</p> <p>Parameters:</p> Name Type Description Default <code>fullpath</code> <code>str</code> <p>Full filepath to the file.</p> required <code>key</code> <code>str | set[str]</code> <p>Key or keys to load. Defaults to all keys.</p> <code>None</code> <code>key_prefix</code> <code>str</code> <p>Key prefix to put before each key. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loaded data. Each value was transform using transform_on_open function.</p> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def open_h5(\n    fullpath: str,\n    key: Optional[Union[str, Set[str]]] = None,\n    key_prefix: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Open h5 file and return dict.\n\n    Args:\n        fullpath (str): Full filepath to the file.\n        key (str | set[str], optional): Key or keys to load. Defaults to all keys.\n        key_prefix (str, optional): Key prefix to put before each key. Defaults to None.\n\n    Returns:\n        dict: The loaded data. Each value was transform using transform_on_open function.\n    \"\"\"\n    with h5py.File(fullpath, \"r\") as file:\n        if key_prefix is None:\n            return open_h5_group(file, key=key)\n        return open_h5_group(file[key_prefix], key=key)  # type: ignore\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.open_h5_group","title":"open_h5_group","text":"<pre><code>open_h5_group(group, key=None, key_prefix=None)\n</code></pre> <p>Open h5 group and return dict.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Union[File, Group]</code> <p>group to open</p> required <code>key</code> <code>Optional[Union[str, Set[str]]]</code> <p>Keys to load. Defaults to None.</p> <code>None</code> <code>key_prefix</code> <code>Optional[str]</code> <p>Key prefix. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The loaded data. Each value was transform using transform_on_open function.</p> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def open_h5_group(\n    group: Union[h5py.File, h5py.Group],\n    key: Optional[Union[str, Set[str]]] = None,\n    key_prefix: Optional[str] = None,\n) -&gt; dict:\n    \"\"\"Open h5 group and return dict.\n\n    Args:\n        group (Union[h5py.File, h5py.Group]): group to open\n        key (Optional[Union[str, Set[str]]], optional): Keys to load. Defaults to None.\n        key_prefix (Optional[str], optional): Key prefix. Defaults to None.\n\n    Returns:\n        dict: The loaded data. Each value was transform using transform_on_open function.\n    \"\"\"\n    data = {}\n    if key is not None:\n        key = key if isinstance(key, set) else set([key])\n\n    for group_key in group.keys():\n        key = key if key_prefix is None else f\"{key_prefix}/{key}\"\n        if key is not None and group_key not in key:\n            continue\n        value = group[group_key]\n        if isinstance(value, h5py.Group):\n            data[group_key] = open_h5_group(value)\n        else:\n            data[group_key] = transform_on_open(value[()])  # type: ignore\n    return data\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.save_dict","title":"save_dict","text":"<pre><code>save_dict(filename, data, key_prefix=None, use_compression=None)\n</code></pre> <p>Save dict to h5 file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Full filepath to the file.</p> required <code>data</code> <code>dict</code> <p>Data to save.</p> required <code>key_prefix</code> <code>str</code> <p>Key prefix of the desired location inside h5 file. If nested use <code>key1/key2</code>. Defaults to None, i.e. root of the file.</p> <code>None</code> <code>use_compression</code> <code>str | True</code> <p>If compression should be used. If true, 'gzip' is used, otherwise you can specify compression by providing a str. Defaults to not compressed.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Time of the last modification of the file.</p> Example <pre><code>save_dict('/path/to/file.h5', {'key1': 1})\n</code></pre> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def save_dict(\n    filename: str,\n    data: dict,\n    key_prefix: Optional[str] = None,\n    use_compression: Optional[Union[Literal[True], str]] = None,\n) -&gt; float:\n    \"\"\"Save dict to h5 file.\n\n    Args:\n        filename (str): Full filepath to the file.\n        data (dict): Data to save.\n        key_prefix (str, optional): Key prefix of the desired location inside h5 file.\n         If nested use `key1/key2`. Defaults to None, i.e. root of the file.\n        use_compression (str|True, optional): If compression should be used. If true,\n         'gzip' is used, otherwise you can specify compression by providing a str.\n         Defaults to not compressed.\n\n    Returns:\n        float: Time of the last modification of the file.\n\n    Example:\n        ```\n        save_dict('/path/to/file.h5', {'key1': 1})\n        ```\n\n\n\n    \"\"\"\n    dirname = os.path.dirname(filename)\n    if dirname and not os.path.exists(dirname):\n        os.makedirs(dirname, exist_ok=True)\n\n    mode = \"a\"  # if os.path.exists(filename) else 'w'\n    with LockFile(filename), h5py.File(filename, mode) as file:\n        for key, value in data.items():\n            key = key if key_prefix is None else f\"{key_prefix}/{key}\"\n            if key in file:  # .keys():\n                file.pop(key)\n            if value is None:\n                continue\n            save_sub_dict(file, value, key, use_compression=use_compression)\n    return os.path.getmtime(filename)\n</code></pre>"},{"location":"dh5/h5_utils/#dh5.dh5_class.h5py_utils.save_sub_dict","title":"save_sub_dict","text":"<pre><code>save_sub_dict(group, data, key, use_compression=None)\n</code></pre> <p>Save the dict to a group. Each object is converted to a dict, array or simple value.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>Union[File, Group]</code> <p>h5 group where to save.</p> required <code>data</code> <code>Union[dict, list, ndarray, ClassWithAsdict]</code> <p>Any object that either has 'asdict' or 'asarray' method, either is a dict, list or np.ndarray, either can be transformed using transform_not_dict_on_save function.</p> required <code>key</code> <code>str</code> <p>Desire key for the data inside h5 file .</p> required <code>use_compression</code> <code>str | True</code> <p>If compression should be used. If true, 'gzip' is used, otherwise you can specify compression by providing a str. Defaults to not compressed.</p> <code>None</code> Source code in <code>dh5/dh5_class/h5py_utils.py</code> <pre><code>def save_sub_dict(\n    group: Union[h5py.File, h5py.Group],\n    data: Union[dict, list, np.ndarray, ClassWithAsdict],\n    key: str,\n    use_compression: Optional[Union[Literal[True], str]] = None,\n):\n    \"\"\"Save the dict to a group. Each object is converted to a dict, array or simple value.\n\n    Args:\n        group (Union[h5py.File, h5py.Group]): h5 group where to save.\n        data (Union[dict, list, np.ndarray, ClassWithAsdict]): Any object that either has 'asdict'\n         or 'asarray' method, either is a dict, list or np.ndarray, either can be transformed\n         using transform_not_dict_on_save function.\n        key (str): Desire key for the data inside h5 file .\n        use_compression (str|True, optional): If compression should be used.\n         If true, 'gzip' is used, otherwise you can specify compression by providing a str.\n         Defaults to not compressed.\n    \"\"\"\n    if hasattr(data, \"asdict\"):\n        data = data.asdict()  # type: ignore\n    if hasattr(data, \"asarray\"):\n        data = data.asarray()  # type: ignore\n    if isinstance(data, dict):\n        g = group.create_group(key)\n        for k, v in data.items():\n            save_sub_dict(g, v, k, use_compression=use_compression)\n    elif (key is not None) and (data is not None):\n        data = transform_not_dict_on_save(data)  # type: ignore\n        if isinstance(data, (np.ndarray, list)):\n            use_compression = \"gzip\" if use_compression is True else use_compression\n            group.create_dataset(\n                key, data=data, compression=use_compression\n            )  # compression=\"gzip\"\n        else:\n            group.create_dataset(key, data=data)\n</code></pre>"},{"location":"dh5/methods/","title":"DH5 Class.","text":"<p>DH5 - Dict that is synchronized with .h5 file.</p>"},{"location":"dh5/methods/#dh5.DH5--usage-and-initialization","title":"Usage and initialization","text":"<p>DH5 can open files in 3 different modes:</p> <ul> <li>'r' - Read mode. No data chan be modified.</li> <li>'w' - Write mode. If file exists it will be overwritten. And you have full control on data.</li> <li>'a' - Append mode. If file exists it will be opened. And you have full control on data.</li> </ul> <p>To overwrite file use <code>open_overwrite</code> method or <code>mode=\"w\"</code> with <code>overwrite=True</code>.</p>"},{"location":"dh5/methods/#dh5.DH5--examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n&gt;&gt;&gt; sd['a'] = 5\n&gt;&gt;&gt; sd.save()\n\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a']\n5\n&gt;&gt;&gt; sd_read.a\n5\n\n&gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n&gt;&gt;&gt; sd_append['b'] = 6\n&gt;&gt;&gt; sd_append.save()\n\n&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a'], sd_read['b']\n(5, 6)\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>class DH5:\n    \"\"\"DH5 - Dict that is synchronized with .h5 file.\n\n    # Usage and initialization\n    DH5 can open files in 3 different modes:\n\n    - 'r' - Read mode. No data chan be modified.\n    - 'w' - Write mode. If file exists it will be overwritten. And you have full control on data.\n    - 'a' - Append mode. If file exists it will be opened. And you have full control on data.\n\n    To overwrite file use `open_overwrite` method or `mode=\"w\"` with `overwrite=True`.\n\n\n    # Examples\n        &gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n        &gt;&gt;&gt; sd['a'] = 5\n        &gt;&gt;&gt; sd.save()\n\n        &gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n        &gt;&gt;&gt; sd_read['a']\n        5\n        &gt;&gt;&gt; sd_read.a\n        5\n\n        &gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n        &gt;&gt;&gt; sd_append['b'] = 6\n        &gt;&gt;&gt; sd_append.save()\n\n        &gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n        &gt;&gt;&gt; sd_read['a'], sd_read['b']\n        (5, 6)\n\n    \"\"\"\n\n    _repr: Optional[str] = None\n    _default_attr = [\"get\", \"items\", \"keys\", \"pop\", \"update\", \"values\", \"save\"]\n    _last_data_saved: bool = False\n    _filepath: Optional[str] = None\n    _read_only: Union[bool, Set[str]]\n    _raise_file_locked_error: bool = False\n    _retry_on_file_locked_error: int = 5\n    _last_time_data_checked: float = 0\n    _file_modified_time: float = 0\n    __should_initialized: bool = False\n    __should_not_be_converted__ = True\n\n    def __init__(\n        self,\n        filepath_or_data: Optional[Union[str, dict, Path]] = None,\n        /,\n        mode: Optional[Literal[\"r\", \"w\", \"a\", \"w=\", \"a=\"]] = None,\n        *,\n        filepath: Optional[Union[str, Path]] = None,\n        save_on_edit: bool = False,\n        read_only: Optional[Union[bool, Set[str]]] = None,\n        overwrite: Optional[bool] = None,\n        data: Optional[dict] = None,\n        open_on_init: Optional[bool] = None,\n        **kwds,\n    ):\n        \"\"\"DH5.\n\n        Args:\n            filepath_or_data (str|dict, optional): either filepath, either data as dict.\n            filepath (str|Path, optional): filepath to load. Defaults to None.\n            save_on_edit (bool, optional): Save data as soon as you changed it.\n                Defaults to False. And data should be saved using `save()` method.\n            read_only (bool, optional): opens file in read_only mode, i.e. it cannot be modified.\n                Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.\n            overwrite (Optional[bool], optional):\n                If file exists, it should be explicitly precised.\n                By default raises an error if file exist.\n            data (Optional[dict], optional):\n                Data to load. If data provided, file . Defaults to None.\n            open_on_init (Optional[bool], optional): open_on_init. Defaults to True.\n\n        \"\"\"\n        if mode is not None:\n            if mode.startswith(\"w\"):\n                read_only = False\n            elif mode.startswith(\"a\"):\n                read_only = False\n                overwrite = False\n            elif mode == \"r\":\n                read_only = True\n            if mode.endswith(\"=\"):\n                save_on_edit = True\n\n        if filepath_or_data is not None and hasattr(filepath_or_data, \"keys\"):\n            if not isinstance(filepath_or_data, dict):\n                filepath_or_data = {key: filepath_or_data[key] for key in filepath_or_data.keys()}  # type: ignore\n            data = data or filepath_or_data\n\n        if isinstance(filepath_or_data, (str, Path)):\n            filepath = filepath or filepath_or_data\n\n        if filepath and not isinstance(filepath, str):\n            filepath = str(filepath)\n\n        self._data: Dict[str, Any] = data or {}\n        # transform_to_possible_formats(self._data)\n        self._keys: Set[str] = set(self._data.keys())\n        self._last_update = set()\n        self._save_on_edit = save_on_edit\n        self._classes_should_be_saved_internally = set()\n        self._key_prefix: Optional[str] = kwds.get(\"key_prefix\")\n\n        if read_only is None:\n            read_only = (\n                save_on_edit is False and not overwrite\n            ) and filepath is not None\n\n        if open_on_init is False and overwrite is True:\n            raise ValueError(\"Cannot overwrite file and open_on_init=False mode\")\n        self._open_on_init = (\n            open_on_init if open_on_init is not None else (None if self._data else True)\n        )\n        self._unopened_keys = set()\n\n        # if keep_up_to_data and read_only is True:\n        # raise ValueError(\"Cannot open file in read-only and keep_up_to_data=True mode\")\n        # self._keep_up_to_data = keep_up_to_data\n\n        self._read_only = read_only\n        if filepath is not None:\n            filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n\n            if (overwrite or save_on_edit) and read_only:\n                raise ValueError(\n                    \"\"\"Cannot open file in read_only mode and overwrite it.\"\"\"\n                )\n\n            if os.path.exists(filepath):\n                if overwrite is None and not read_only:\n                    raise FileExistsError(\n                        \"File with the same name already exists. So you should explicitly \"\n                        \"provide what to do with it. Set `overwrite=True` to replace file. \"\n                        \"Set `overwrite=False` if you want to open existing file and work with it.\"\n                    )\n\n                if overwrite and not read_only:\n                    self.__should_initialized = True\n                    # os.remove(filepath)\n\n                if read_only or (not read_only and not overwrite):\n                    if self._open_on_init:\n                        self._load_from_h5(filepath)\n                    elif self._open_on_init is False:\n                        self._keys = h5py_utils.keys_h5(\n                            filepath, key_prefix=self._key_prefix\n                        )\n                        self._unopened_keys.update(self._keys)\n\n            elif read_only:\n                raise ValueError(\n                    f\"Cannot open file in read_only mode if file {filepath} does not exist\"\n                )\n\n            # if not read_only:\n            self._filepath = filepath\n\n    @classmethod\n    def open_overwrite(\n        cls,\n        filepath_or_data: Optional[Union[str, dict, Path]] = None,\n        /,\n        mode: Optional[Literal[\"=\"]] = None,\n        *,\n        filepath: Optional[Union[str, Path]] = None,\n        save_on_edit: bool = False,\n        read_only: Optional[Union[bool, Set[str]]] = None,\n        overwrite: Optional[bool] = True,\n        data: Optional[dict] = None,\n        open_on_init: Optional[bool] = None,\n        **kwds,\n    ):\n        \"\"\"Open file in the overwrite mode.\n\n        It deletes the file if it exists and then opens it in the write mode.\n        Same syntax as `__init__` method.\n        \"\"\"\n        mode_ = \"w=\" if mode == \"=\" else \"w\"\n        return cls(\n            filepath_or_data,\n            mode=mode_,\n            filepath=filepath,\n            save_on_edit=save_on_edit,\n            read_only=read_only,\n            overwrite=overwrite,\n            data=data,\n            open_on_init=open_on_init,\n            **kwds,\n        )\n\n    def __init__filepath__(\n        self, *, filepath: str, filekey: str, save_on_edit: bool = False, **_\n    ):\n        \"\"\"Initialize a filepath. It allows to save sub DH5 objects independently.\n\n        Args:\n            filepath (str): The path to the file to be synced.\n            filekey (str): The key prefix to use for the synced data.\n            save_on_edit (bool, optional): Whether to save the file automatically when it is edited. Defaults to False.\n            **kwargs: Additional keyword arguments to pass to the constructor.\n        \"\"\"\n        self._filepath = filepath\n        self._key_prefix = filekey\n        self._save_on_edit = save_on_edit\n\n    def _load_from_h5(\n        self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n    ) -&gt; Set[str]:\n        \"\"\"Load data from h5 to self._data.\"\"\"\n        filepath = filepath or self._filepath\n        if filepath is None:\n            raise ValueError(\"Filepath is not specified. So cannot load_h5\")\n        filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n        data = h5py_utils.open_h5(filepath, key=key, key_prefix=self._key_prefix)\n        self._file_modified_time = os.path.getmtime(filepath)\n        return self._update(data)\n\n    def load(\n        self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n    ):\n        \"\"\"Load data from h5 into current object.\"\"\"\n        updated_from_other_file = filepath is not None\n        updated_key = self._load_from_h5(filepath=filepath, key=key)\n        if updated_from_other_file:\n            for key in updated_key:\n                self._keys.add(key)\n\n        return self\n\n    def lock_data(self: _SELF, keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n        \"\"\"Locks the specified keys in the database so they cannot be changed.\n\n        Args:\n            keys: An optional iterable of strings representing the keys to be locked.\n            If None, all keys will be locked.\n\n        Returns:\n            A reference to the DH5 object.\n\n        Raises:\n            ValueError: If everything is already locked by read_only mode.\n\n        Examples:\n            &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n            &gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n            &gt;&gt;&gt; sd['key1'] = 2\n            ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n            &gt;&gt;&gt; sd['key2'] = 5\n\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\n                \"Cannot lock specific data and everything is locked by read_only mode\"\n            )\n        if not isinstance(self._read_only, set):\n            self._read_only = set()\n        if keys is None:\n            keys = self.keys()\n        elif isinstance(keys, str):\n            keys = (keys,)\n\n        for key in keys:\n            self._read_only.add(key)\n\n        self._clean_precalculated_results()\n        return self\n\n    def unlock_data(self: _SELF, remove_keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n        \"\"\"Unlock the specified keys in the database so they can be changed.\n\n        If file was opened in read-only mode you cannot unlock it, however you can open\n        it again in 'a' mode and lock all keys except necessary.\n\n        Args:\n            keys: An optional iterable of strings representing the keys to be unlocked.\n            If None, all keys will be unlocked.\n\n        Returns:\n            A reference to the DH5 object.\n\n        Raises:\n            ValueError: If everything is already locked by read_only mode.\n\n        Examples:\n            &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n            &gt;&gt;&gt; sd.lock_data()\n            &gt;&gt;&gt; sd.unlock_data('key2')\n            &gt;&gt;&gt; sd['key2'] = 5\n            &gt;&gt;&gt; sd['key1'] = 2\n            ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\"Cannot unlock is global read_only mode was set to True\")\n        if isinstance(self._read_only, set):\n            if remove_keys is None:\n                self._read_only = False\n            else:\n                if isinstance(remove_keys, str):\n                    remove_keys = (remove_keys,)\n                for key in remove_keys:\n                    if key in self._read_only:\n                        self._read_only.remove(key)\n\n        self._clean_precalculated_results()\n        return self\n\n    def _clean_precalculated_results(self):\n        self._repr = None\n\n    def __add_key(self, key):\n        self._pre_save()\n        self._keys.add(key)\n        self._last_update.add(key)\n\n    def __del_key(self, key):\n        self._keys.remove(key)\n        self._last_update.add(key)\n\n    def __check_read_only_true(self, key):\n        \"\"\"Return true if data with this key is only available for read.\n\n        Takes into account the external constrains.\n        \"\"\"\n        return (self._read_only) and (self._read_only is True or key in self._read_only)\n\n    @editing\n    def update(\n        self: _SELF, __m: Optional[dict] = None, **kwds: \"DICT_OR_LIST_LIKE\"\n    ) -&gt; _SELF:\n        \"\"\"Update data from a dictionary or keyword arguments.\n\n        See `DH5.data_transformation` to learn more\n            about how the types are converted.\n\n        Args:\n            __m (dict | None): A dictionary of key-value pairs to update the DH5 object with.\n            **kwds (DICT_OR_LIST_LIKE): Keyword arguments of key-value pairs to update the DH5 object with.\n\n        Returns:\n            Self.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5()\n            &gt;&gt;&gt; data.update({'a': 1, 'b': 2})\n            DH5({'a': 1, 'b': 2})\n            &gt;&gt;&gt; data.update(c=3, d=4)\n            DH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n\n        \"\"\"\n        if __m is not None:\n            kwds.update(__m)\n\n        for key in kwds:  # pylint: disable=C0206\n            if self.__check_read_only_true(key):\n                raise ReadOnlyKeyError(key)\n            self.__add_key(key)\n            kwds[key] = transform_to_possible_formats(kwds[key])\n\n        # self.pull(auto=True)\n        self._data.update(**kwds)\n        return self\n\n    def _update(self, __m: Optional[dict] = None, **kwds: Any):\n        \"\"\"Update only internal data and attributes.\n\n        Can be modified in read_only mode. Did not change a file.\n        \"\"\"\n        if __m is not None:\n            kwds.update(__m)\n\n        for key in kwds:\n            self._keys.add(key)\n            self._unopened_keys.discard(key)\n\n        self._data.update(kwds)\n\n        return set(kwds.keys())\n\n    @editing\n    def pop(self, key: str) -&gt; Union[Any, NotLoaded]:\n        \"\"\"Remove the specified key and return the value.\n\n        Args:\n            key (str): The key to remove.\n\n        Returns:\n            Same as `get` method, i.e. `DH5` if the value is a dict otherwise the value.\n                If data was never loaded it will return `NotLoaded`. To load data use `get` method.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n            &gt;&gt;&gt; data.pop('b')\n            2\n\n        \"\"\"\n        if self.__check_read_only_true(key):\n            raise ReadOnlyKeyError(key, action=\"pop\")\n        self.__del_key(key)\n        # self.pull(auto=True)\n        if key not in self._unopened_keys:\n            return self._data.pop(key)\n        return NotLoaded()\n\n    @editing\n    def remove(self: _SELF, key: str) -&gt; _SELF:\n        \"\"\"Remove the specified key and self.\n\n        Args:\n            key (str): The key to remove.\n\n        Returns:\n            Self.\n\n        Examples:\n            &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n            &gt;&gt;&gt; data.pop('b')\n            DH5({'a': 1, 'c': 3})\n\n        \"\"\"\n        self.pop(key)\n        return self\n\n    @overload\n    def get_raw(self, __key: str) -&gt; Any:\n        \"\"\"Return element as a dict. Return None if not found.\"\"\"\n\n    @overload\n    def get_raw(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"With default value provided.\"\"\"\n\n    def get_raw(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Return raw value associated with the given key.\n\n        Dictionaries are not converted to the `DH5` unlike `get` method.\n\n        Args:\n            key (str): Key to be searched.\n            default (Any, optional): Value to be returned if the `key` is not found.\n                The default value is `None`.\n\n\n        Returns:\n            Raw value without any conversion or the default value if the key is not found.\n\n        Examples:\n            &gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n            &gt;&gt;&gt; sync_data.get_raw('key1')\n            {'a': 1, 'b': 2}\n            &gt;&gt;&gt; sync_data.get_raw('key2')\n            5\n        \"\"\"\n        return self.__get_data__(key, default)\n\n    @overload\n    def get(self, __key: str) -&gt; Any:\n        \"\"\"Return element as a DH5 class if it's dict. Return None if not found.\"\"\"\n\n    @overload\n    def get(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"With default value provided.\"\"\"\n\n    def get(self, key: str, default: Any = None) -&gt; Any:\n        \"\"\"Retrieve the value associated with the given key from the DH5 object.\n\n        Args:\n            key (str): Key to be searched.\n            default (Any, optional): Value to be returned if the `key` is not found.\n                The default value is `None`.\n\n        Returns:\n            The value associated with the key. If the value is a dict then it's converter\n            into `DH5` object. This conversion take some time, but allow to change, save and\n            this sub-object. For faster performance use `get_raw` method.\n\n        Examples:\n            &gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n            &gt;&gt;&gt; sync_data.get('name')\n            'John'\n            &gt;&gt;&gt; sync_data.get('surname')\n            None\n            &gt;&gt;&gt; sync_data.get('gender', 'unknown')\n            'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n\n        \"\"\"\n        data = self.__get_data__(key, default)\n        if isinstance(data, dict) and data:\n            return DH5(\n                filepath=self._filepath,\n                data=data,\n                overwrite=False,\n                key_prefix=key,\n                read_only=self.__check_read_only_true(key),\n            )\n        return data\n\n    def __getitem__(self, __key: Union[str, tuple]) -&gt; Any:\n        \"\"\"Return raw value associated with the given key.\n\n        Same as `get_raw` but raises error if the key is not found.\n\n        Args:\n            key (str | tuple): The key to retrieve the dictionary for.\n\n        Returns:\n            Raw value without any conversion.\n\n        Raises:\n            KeyError: If the key is not found.\n\n        \"\"\"\n        if isinstance(__key, tuple):\n            if len(__key) &gt; 1:\n                return self.__getitem__(__key[0]).__getitem__(\n                    __key[1:] if len(__key) &gt; 2 else __key[1]\n                )\n            if len(__key) == 1:\n                return self.__getitem__(__key[0])\n            raise ValueError(\n                \"Key should be a string or tuple with at least one element\"\n            )\n        return self.__get_data_or_raise__(__key)\n\n    @editing\n    def __setitem__(\n        self, __key: Union[str, tuple], __value: \"DICT_OR_LIST_LIKE\"\n    ) -&gt; None:\n        \"\"\"Set value corresponding to the given key.\n\n        See [`DH5.data_transformation`](data_transformation.md) to learn more\n            about how the types are converted.\n\n        Args:\n            key (str | tuple): The key to retrieve the dictionary for.\n\n        \"\"\"\n        if isinstance(__key, tuple):\n            if not __key or len(__key) == 1 or len(__key) == 0:\n                raise ValueError(\n                    \"Key should be a string or tuple with at least two elements\"\n                )\n\n            self.__add_key(__key[0])\n            if self.__check_read_only_true(__key[0]):\n                raise ReadOnlyKeyError(__key[0], action=\"set\")\n            return self.__getitem__(__key[0]).__setitem__(\n                __key[1:] if len(__key) &gt; 2 else __key[1], __value  # type: ignore\n            )\n\n        if self.__check_read_only_true(__key):\n            raise ReadOnlyKeyError(__key, action=\"set\")\n\n        self.__add_key(__key)\n        __value = transform_to_possible_formats(__value)\n\n        if self._read_only is not True:\n            if hasattr(__value, \"save\"):\n                self._classes_should_be_saved_internally.add(__key)\n\n            if hasattr(__value, \"__init__filepath__\") and self._filepath:\n                key = (\n                    __key if self._key_prefix is None else f\"{self._key_prefix}/{__key}\"\n                )\n                __value.__init__filepath__(  # type: ignore\n                    filepath=self._filepath,\n                    filekey=key,\n                    save_on_edit=self._save_on_edit,\n                )\n\n            if hasattr(__value, \"__post__init__\"):\n                __value.__post__init__()  # type: ignore\n\n        self.__set_data__(__key, __value)\n        return None\n\n    def __delitem__(self, key: str):\n        self.pop(key)\n\n    def __getattr__(self, __name: str):\n        \"\"\"Call if __getattribute__ does not work.\"\"\"\n        if (\n            len(__name) &gt; 1\n            and __name[0] == \"i\"\n            and __name[1:].isdigit()\n            and __name not in self\n        ):\n            __name = __name[1:]\n        if __name in self:\n            data = self.get(__name)\n            # if isinstance(data, dict) and data:\n            #     return DH5(filepath=self._filepath, data=data, key_prefix=__name)\n            return data\n        raise AttributeError(f\"No attribute {__name} found in DH5\")\n\n    def __setattr__(self, __name: str, __value: \"DICT_OR_LIST_LIKE\") -&gt; None:\n        \"\"\"Call every time you set an attribute.\"\"\"\n        if __name.startswith(\"_\"):\n            return object.__setattr__(self, __name, __value)\n\n        if isinstance(vars(self.__class__).get(__name), property):\n            return object.__setattr__(self, __name, __value)\n        return self.__setitem__(__name, __value)\n\n    def __delattr__(self, __name: str) -&gt; None:\n        if __name in self:\n            return self.__delitem__(__name)\n        return object.__delattr__(self, __name)\n\n    @overload\n    def __get_data__(self, __key: str) -&gt; Optional[None]:\n        \"\"\"Return None if the data doesn't contain key.\"\"\"\n\n    @overload\n    def __get_data__(self, __key: str, __default: _T) -&gt; Union[Any, _T]:\n        \"\"\"Return default value if the data doesn't contain key.\"\"\"\n\n    def __get_data__(self, __key: str, __default: Any = None):\n        if __key in self._unopened_keys:\n            self._load_from_h5(key=__key)\n        data = self._data.get(__key, __default)\n        if isinstance(data, NotLoaded):\n            self._load_from_h5(key=__key)\n            data = self._data.get(__key, __default)\n        if self.__check_read_only_true(__key):\n            if hasattr(data, \"_read_only\"):\n                data._read_only = True  # type: ignore # pylint: disable=protected-access\n            else:\n                data = deepcopy(data)\n        return data\n\n    def __get_data_or_raise__(self, __key):\n        # self.pull(auto=True)\n        if __key in self._unopened_keys:\n            self._load_from_h5(key=__key)\n        data = self._data.__getitem__(__key)\n        if isinstance(data, NotLoaded):\n            self._load_from_h5(key=__key)\n            data = self._data.__getitem__(__key)\n        if self.__check_read_only_true(__key):\n            if hasattr(data, \"_read_only\"):\n                data._read_only = True  # type: ignore # pylint: disable=protected-access\n            else:\n                data = deepcopy(data)\n        return data\n\n    def __set_data__(self, __key: str, __value):\n        # self.pull(auto=True)\n        return self._data.__setitem__(__key, __value)\n\n    def items(self):\n        \"\"\"Return all items in the collection.\n\n        It opens all items that were not opened yet and return dictionary iterator.\n        \"\"\"\n        if self._unopened_keys:\n            self._load_from_h5(key=self._unopened_keys)\n        return self._data.items()\n\n    def values(self):\n        \"\"\"Return all values in the collection.\n\n        It opens all items that were not opened yet and return dictionary iterator.\n        \"\"\"\n        # self.pull(auto=True)\n        if self._unopened_keys:\n            self._load_from_h5(key=self._unopened_keys)\n        return self._data.values()\n\n    def keys(self) -&gt; Set[str]:\n        \"\"\"Return all keys in the collection.\"\"\"\n        # self.pull(auto=True)\n        return self._keys.copy().union(self._unopened_keys.copy())\n\n    def keys_tree(self) -&gt; Dict[str, Optional[dict]]:\n        \"\"\"Return dict of the keys, where value always is a dict or None.\n\n        Examples:\n            ```\n            &gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n            &gt;&gt;&gt; sd.keys_tree()\n            {'a': {'b': None}, 'c': None}\n            ```\n\n        For all unopened keys, it does not open them and does not explore the structure.\n        \"\"\"\n        structure = get_keys_structure(self._data)\n\n        for key in self._unopened_keys:\n            structure[key] = None\n        return structure\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def _get_repr(self):\n        if self._repr is None:\n            additional_info = (\n                {key: \" (r)\" for key in self._read_only}\n                if isinstance(self._read_only, set)\n                else None\n            )\n            self._repr = output_dict_structure(\n                self._data, additional_info=additional_info\n            ) + (\n                f\"\\nUnloaded keys: {self._unopened_keys}\" if self._unopened_keys else \"\"\n            )\n\n    def __repr__(self):\n        self._get_repr()\n\n        not_saved = (\n            \"\" if self._last_data_saved or self._read_only is True else \" (not saved)\"\n        )\n        mode = (\n            \"r\"\n            if self._read_only is True\n            else \"w\" if self._read_only is False else \"rw\"\n        )\n        mode = \"l\" if self._filepath is None and self._read_only is not True else mode\n        not_saved = \"\" if mode == \"l\" else not_saved\n\n        return f\"{type(self).__name__} ({mode}){not_saved}: \\n {self._repr}\"\n\n    def __str__(self):\n        return self.__repr__()\n\n    def __contains__(self, item):\n        return (item in self._data) or (item in self._unopened_keys)\n\n    def __dir__(self) -&gt; Iterable[str]:\n        return list(self._keys) + self._default_attr\n\n    def __similar__(self, other: \"DH5\") -&gt; bool:\n        \"\"\"Check if 2 DH5 are similar.\n\n        It means: same file, mode, save_on_edit. Does not check the data.\n        \"\"\"\n        return (\n            self._filepath == other._filepath  # pylint: disable=protected-access\n            and self._read_only == other._read_only  # pylint: disable=protected-access\n            and self._save_on_edit\n            == other._save_on_edit  # pylint: disable=protected-access\n            and self.__should_initialized\n            == other.__should_initialized  # pylint: disable=protected-access\n        )\n\n    def _pre_save(self, *args, **kwargs):\n        del args, kwargs\n        if self.__should_initialized and self._filepath:\n            os.remove(self._filepath)\n            self.__should_initialized = False\n\n    def save(\n        self,\n        only_update: Union[bool, Iterable[str]] = True,\n        filepath: Optional[str] = None,\n        force: Optional[bool] = None,\n    ):\n        \"\"\"Save the data to a file.\n\n        Args:\n            only_update (Union[bool, Iterable[str]], optional): Determines whether to save only\n                the updated data or all data.\n                If True, only the updated data will be saved. If False, all data will be saved.\n                If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.\n            filepath (str, optional): The path to the file where the data will be saved.\n                If not provided, the default filepath will be used. Defaults to None.\n            force (bool, optional): Determines whether to force the save operation, even if only_update is True.\n                If True, the save operation will be forced. If False or None, the save operation\n                will be performed according to the value of only_update. Defaults to None.\n\n        Returns:\n            self\n\n        Raises:\n            ValueError: If the file is opened in read-only mode, it cannot be saved.\n                The file should be reopened in write mode before saving.\n        \"\"\"\n        if self._read_only is True:\n            raise ValueError(\n                \"Cannot save opened in a read-only mode. Should reopen the file\"\n            )\n\n        self._pre_save()\n\n        if force is True or filepath is not None:\n            only_update = False\n\n        if isinstance(only_update, Iterable):\n            last_update = self._last_update.intersection(only_update)\n            self._last_update = self._last_update.difference(only_update)\n        else:\n            last_update, self._last_update = self._last_update, set()\n\n        if len(self._last_update) == 0:\n            self._last_data_saved = True\n\n        filepath = self._check_if_filepath_was_set(filepath, self._filepath)\n\n        if only_update is False:\n            if self._read_only is False:\n                data_to_save = self._data\n            else:\n                data_to_save = {\n                    key: value\n                    for key, value in self._data.items()\n                    if key not in self._read_only or key in last_update\n                }\n            data_to_save.update(\n                {\n                    key: None\n                    for key in last_update\n                    if (key not in self._data) and not self.__check_read_only_true(key)\n                }\n            )\n\n            self.__h5py_utils_save_dict_with_retry(filepath=filepath, data=data_to_save)\n\n            return self\n\n        for key in last_update:\n            if key in self._classes_should_be_saved_internally:\n                obj = self._data[key]\n                if hasattr(obj, \"save\"):\n                    self._data[key].save(only_update=only_update)\n                else:\n                    self._classes_should_be_saved_internally.remove(key)\n\n        self.__h5py_utils_save_dict_with_retry(\n            filepath=filepath,\n            data={\n                key: self._data.get(key)\n                for key in last_update\n                if key not in self._classes_should_be_saved_internally\n            },\n        )\n\n        return self\n\n    def __h5py_utils_save_dict_with_retry(self, filepath: str, data: dict):\n        # print(\"open\", time.time(), self._raise_file_locked_error)\n        for i in range(self._retry_on_file_locked_error):\n            try:\n                # print(\"_raise_file_locked_error\", self._raise_file_locked_error, list(data.keys()))\n                self._file_modified_time = h5py_utils.save_dict(\n                    filename=filepath + \".h5\", data=data, key_prefix=self._key_prefix\n                )\n                return\n            except h5py_utils.FileLockedError as error:\n                if self._raise_file_locked_error:\n                    raise error\n                logging.info(\"File is locked. waiting 2s and %d more retrying.\", i)\n                from ..utils import async_utils\n\n                async_utils.sleep(1)\n\n        raise h5py_utils.FileLockedError(\n            f\"Even after {self._retry_on_file_locked_error} data was not saved\"\n        )\n\n    @staticmethod\n    def _check_if_filepath_was_set(\n        filepath: Optional[str], filepath2: Optional[str]\n    ) -&gt; str:\n        \"\"\"Return path to the file with filename, but without extension.\"\"\"\n        filepath = filepath or filepath2\n        if filepath is None:\n            raise ValueError(\n                \"Should provide filepath or set self.filepath before saving\"\n            )\n        filepath = (\n            (filepath.rsplit(\".h5\", 1)[0]) if filepath.endswith(\".h5\") else filepath\n        )\n        return filepath\n\n    @property\n    def filepath(self):\n        \"\"\"Return the filepath without the '.h5' extension.\n\n        If the filepath is None, returns None.\n        \"\"\"\n        return None if self._filepath is None else (self._filepath.rsplit(\".h5\", 1)[0])\n\n    @filepath.setter\n    def filepath(self, value: str):\n        if not isinstance(value, str):\n            value = str(value)\n        self._filepath = value if value.endswith(\".h5\") else value + \".h5\"\n\n    @property\n    def filename(self) -&gt; Optional[str]:\n        \"\"\"Return the filename of the current filepath without '.h5' extension.\n\n        Returns:\n            Optional[str]: The filename of the current filepath, or None if the filepath is None.\n        \"\"\"\n        filepath = self.filepath\n        if filepath is None:\n            return None\n        return os.path.basename(filepath)\n\n    @property\n    def save_on_edit(self):\n        \"\"\"Return the current value of the save_on_edit attribute.\"\"\"\n        return self._save_on_edit\n\n    def asdict(self):\n        \"\"\"Return the internal data of the object as a dictionary.\n\n        Returns:\n            dict: A dictionary representation of the object's internal data.\n        \"\"\"\n        return self._data\n\n    def pull_available(self):\n        \"\"\"Check if the file has been modified elsewhere since the last save.\n\n        Raises:\n            ValueError: If the filepath has not been set.\n\n        Returns:\n            bool: True if the file has been modified, False otherwise.\n        \"\"\"\n        if self.filepath is None:\n            raise ValueError(\"Cannot pull from file if it's not been set\")\n        file_modified = os.path.getmtime(self.filepath + \".h5\")\n        return self._file_modified_time != file_modified\n\n    def pull(self, force_pull: bool = False):\n        \"\"\"Pull data from a file and reloads it into the object.\n\n        Args:\n            force_pull (bool, optional): If True, forces to update data even if the file\n            has not been modified. Defaults to False.\n\n        Raises:\n            ValueError: If the filepath has not been set.\n\n        Returns:\n            self: The updated object.\n        \"\"\"\n        if self.filepath is None:\n            raise ValueError(\"Cannot pull from file if it's not been set\")\n\n        if force_pull or self.pull_available():\n            logging.debug(\"File modified so it will be reloaded.\")\n            self._data = {}\n            self._keys = set()\n            self._clean_precalculated_results()\n            self._load_from_h5()\n\n        return self\n\n    @overload\n    def close_data(self, key: None = None, every: Literal[True] = True):\n        \"\"\"Close every opened key so it could be collected by the garbage collector afterwards.\"\"\"\n\n    @overload\n    def close_data(self, key: Iterable[str]):\n        \"\"\"Close every key provided so it could be collected by the garbage collector afterwards.\"\"\"\n\n    @overload\n    def close_data(self, key: str):  # type: ignore\n        \"\"\"Close the key so it could be collected by the garbage collector afterwards.\"\"\"\n\n    def close_data(\n        self,\n        key: Optional[Union[str, Iterable[str]]] = None,\n        every: Optional[Literal[True]] = None,\n    ):\n        \"\"\"Close the key so it could be collected by the garbage collector afterwards.\n\n        Args:\n            key (str | Iterable[str], optional): key or keys that should be closed. Defaults to None.\n            every (True, optional): put to True if all keys should be closed. Defaults to None.\n\n        Raises:\n            ValueError: if both key and every are not provided.\n\n        Returns:\n            Self.\n        \"\"\"\n        if every is True:\n            for k in self.keys():\n                self.close_data(k)\n            return self\n        elif key is None:\n            raise ValueError(\"Should provide key or every=True.\")\n\n        if not isinstance(key, str):\n            for k in key:\n                self.close_data(k)\n            return self\n\n        if key not in self._unopened_keys:\n            self._data.pop(key)\n        self._unopened_keys.add(key)\n\n        return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.filename","title":"filename  <code>property</code>","text":"<pre><code>filename\n</code></pre> <p>Return the filename of the current filepath without '.h5' extension.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The filename of the current filepath, or None if the filepath is None.</p>"},{"location":"dh5/methods/#dh5.DH5.filepath","title":"filepath  <code>property</code> <code>writable</code>","text":"<pre><code>filepath\n</code></pre> <p>Return the filepath without the '.h5' extension.</p> <p>If the filepath is None, returns None.</p>"},{"location":"dh5/methods/#dh5.DH5.save_on_edit","title":"save_on_edit  <code>property</code>","text":"<pre><code>save_on_edit\n</code></pre> <p>Return the current value of the save_on_edit attribute.</p>"},{"location":"dh5/methods/#dh5.DH5.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(__key)\n</code></pre> <p>Return raw value associated with the given key.</p> <p>Same as <code>get_raw</code> but raises error if the key is not found.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | tuple</code> <p>The key to retrieve the dictionary for.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Raw value without any conversion.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If the key is not found.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def __getitem__(self, __key: Union[str, tuple]) -&gt; Any:\n    \"\"\"Return raw value associated with the given key.\n\n    Same as `get_raw` but raises error if the key is not found.\n\n    Args:\n        key (str | tuple): The key to retrieve the dictionary for.\n\n    Returns:\n        Raw value without any conversion.\n\n    Raises:\n        KeyError: If the key is not found.\n\n    \"\"\"\n    if isinstance(__key, tuple):\n        if len(__key) &gt; 1:\n            return self.__getitem__(__key[0]).__getitem__(\n                __key[1:] if len(__key) &gt; 2 else __key[1]\n            )\n        if len(__key) == 1:\n            return self.__getitem__(__key[0])\n        raise ValueError(\n            \"Key should be a string or tuple with at least one element\"\n        )\n    return self.__get_data_or_raise__(__key)\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.__init__","title":"__init__","text":"<pre><code>__init__(filepath_or_data=None, /, mode=None, *, filepath=None, save_on_edit=False, read_only=None, overwrite=None, data=None, open_on_init=None, **kwds)\n</code></pre> <p>DH5.</p> <p>Parameters:</p> Name Type Description Default <code>filepath_or_data</code> <code>str | dict</code> <p>either filepath, either data as dict.</p> <code>None</code> <code>filepath</code> <code>str | Path</code> <p>filepath to load. Defaults to None.</p> <code>None</code> <code>save_on_edit</code> <code>bool</code> <p>Save data as soon as you changed it. Defaults to False. And data should be saved using <code>save()</code> method.</p> <code>False</code> <code>read_only</code> <code>bool</code> <p>opens file in read_only mode, i.e. it cannot be modified. Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.</p> <code>None</code> <code>overwrite</code> <code>Optional[bool]</code> <p>If file exists, it should be explicitly precised. By default raises an error if file exist.</p> <code>None</code> <code>data</code> <code>Optional[dict]</code> <p>Data to load. If data provided, file . Defaults to None.</p> <code>None</code> <code>open_on_init</code> <code>Optional[bool]</code> <p>open_on_init. Defaults to True.</p> <code>None</code> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def __init__(\n    self,\n    filepath_or_data: Optional[Union[str, dict, Path]] = None,\n    /,\n    mode: Optional[Literal[\"r\", \"w\", \"a\", \"w=\", \"a=\"]] = None,\n    *,\n    filepath: Optional[Union[str, Path]] = None,\n    save_on_edit: bool = False,\n    read_only: Optional[Union[bool, Set[str]]] = None,\n    overwrite: Optional[bool] = None,\n    data: Optional[dict] = None,\n    open_on_init: Optional[bool] = None,\n    **kwds,\n):\n    \"\"\"DH5.\n\n    Args:\n        filepath_or_data (str|dict, optional): either filepath, either data as dict.\n        filepath (str|Path, optional): filepath to load. Defaults to None.\n        save_on_edit (bool, optional): Save data as soon as you changed it.\n            Defaults to False. And data should be saved using `save()` method.\n        read_only (bool, optional): opens file in read_only mode, i.e. it cannot be modified.\n            Defaults to (save_on_edit is False &amp;&amp; overwrite is False) and filepath is set.\n        overwrite (Optional[bool], optional):\n            If file exists, it should be explicitly precised.\n            By default raises an error if file exist.\n        data (Optional[dict], optional):\n            Data to load. If data provided, file . Defaults to None.\n        open_on_init (Optional[bool], optional): open_on_init. Defaults to True.\n\n    \"\"\"\n    if mode is not None:\n        if mode.startswith(\"w\"):\n            read_only = False\n        elif mode.startswith(\"a\"):\n            read_only = False\n            overwrite = False\n        elif mode == \"r\":\n            read_only = True\n        if mode.endswith(\"=\"):\n            save_on_edit = True\n\n    if filepath_or_data is not None and hasattr(filepath_or_data, \"keys\"):\n        if not isinstance(filepath_or_data, dict):\n            filepath_or_data = {key: filepath_or_data[key] for key in filepath_or_data.keys()}  # type: ignore\n        data = data or filepath_or_data\n\n    if isinstance(filepath_or_data, (str, Path)):\n        filepath = filepath or filepath_or_data\n\n    if filepath and not isinstance(filepath, str):\n        filepath = str(filepath)\n\n    self._data: Dict[str, Any] = data or {}\n    # transform_to_possible_formats(self._data)\n    self._keys: Set[str] = set(self._data.keys())\n    self._last_update = set()\n    self._save_on_edit = save_on_edit\n    self._classes_should_be_saved_internally = set()\n    self._key_prefix: Optional[str] = kwds.get(\"key_prefix\")\n\n    if read_only is None:\n        read_only = (\n            save_on_edit is False and not overwrite\n        ) and filepath is not None\n\n    if open_on_init is False and overwrite is True:\n        raise ValueError(\"Cannot overwrite file and open_on_init=False mode\")\n    self._open_on_init = (\n        open_on_init if open_on_init is not None else (None if self._data else True)\n    )\n    self._unopened_keys = set()\n\n    # if keep_up_to_data and read_only is True:\n    # raise ValueError(\"Cannot open file in read-only and keep_up_to_data=True mode\")\n    # self._keep_up_to_data = keep_up_to_data\n\n    self._read_only = read_only\n    if filepath is not None:\n        filepath = filepath if filepath.endswith(\".h5\") else filepath + \".h5\"\n\n        if (overwrite or save_on_edit) and read_only:\n            raise ValueError(\n                \"\"\"Cannot open file in read_only mode and overwrite it.\"\"\"\n            )\n\n        if os.path.exists(filepath):\n            if overwrite is None and not read_only:\n                raise FileExistsError(\n                    \"File with the same name already exists. So you should explicitly \"\n                    \"provide what to do with it. Set `overwrite=True` to replace file. \"\n                    \"Set `overwrite=False` if you want to open existing file and work with it.\"\n                )\n\n            if overwrite and not read_only:\n                self.__should_initialized = True\n                # os.remove(filepath)\n\n            if read_only or (not read_only and not overwrite):\n                if self._open_on_init:\n                    self._load_from_h5(filepath)\n                elif self._open_on_init is False:\n                    self._keys = h5py_utils.keys_h5(\n                        filepath, key_prefix=self._key_prefix\n                    )\n                    self._unopened_keys.update(self._keys)\n\n        elif read_only:\n            raise ValueError(\n                f\"Cannot open file in read_only mode if file {filepath} does not exist\"\n            )\n\n        # if not read_only:\n        self._filepath = filepath\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(__key, __value)\n</code></pre> <p>Set value corresponding to the given key.</p> <p>See <code>DH5.data_transformation</code> to learn more     about how the types are converted.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | tuple</code> <p>The key to retrieve the dictionary for.</p> required Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef __setitem__(\n    self, __key: Union[str, tuple], __value: \"DICT_OR_LIST_LIKE\"\n) -&gt; None:\n    \"\"\"Set value corresponding to the given key.\n\n    See [`DH5.data_transformation`](data_transformation.md) to learn more\n        about how the types are converted.\n\n    Args:\n        key (str | tuple): The key to retrieve the dictionary for.\n\n    \"\"\"\n    if isinstance(__key, tuple):\n        if not __key or len(__key) == 1 or len(__key) == 0:\n            raise ValueError(\n                \"Key should be a string or tuple with at least two elements\"\n            )\n\n        self.__add_key(__key[0])\n        if self.__check_read_only_true(__key[0]):\n            raise ReadOnlyKeyError(__key[0], action=\"set\")\n        return self.__getitem__(__key[0]).__setitem__(\n            __key[1:] if len(__key) &gt; 2 else __key[1], __value  # type: ignore\n        )\n\n    if self.__check_read_only_true(__key):\n        raise ReadOnlyKeyError(__key, action=\"set\")\n\n    self.__add_key(__key)\n    __value = transform_to_possible_formats(__value)\n\n    if self._read_only is not True:\n        if hasattr(__value, \"save\"):\n            self._classes_should_be_saved_internally.add(__key)\n\n        if hasattr(__value, \"__init__filepath__\") and self._filepath:\n            key = (\n                __key if self._key_prefix is None else f\"{self._key_prefix}/{__key}\"\n            )\n            __value.__init__filepath__(  # type: ignore\n                filepath=self._filepath,\n                filekey=key,\n                save_on_edit=self._save_on_edit,\n            )\n\n        if hasattr(__value, \"__post__init__\"):\n            __value.__post__init__()  # type: ignore\n\n    self.__set_data__(__key, __value)\n    return None\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.asdict","title":"asdict","text":"<pre><code>asdict()\n</code></pre> <p>Return the internal data of the object as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the object's internal data.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def asdict(self):\n    \"\"\"Return the internal data of the object as a dictionary.\n\n    Returns:\n        dict: A dictionary representation of the object's internal data.\n    \"\"\"\n    return self._data\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.close_data","title":"close_data","text":"<pre><code>close_data(key=None, every=None)\n</code></pre> <p>Close the key so it could be collected by the garbage collector afterwards.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str | Iterable[str]</code> <p>key or keys that should be closed. Defaults to None.</p> <code>None</code> <code>every</code> <code>True</code> <p>put to True if all keys should be closed. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if both key and every are not provided.</p> <p>Returns:</p> Type Description <p>Self.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def close_data(\n    self,\n    key: Optional[Union[str, Iterable[str]]] = None,\n    every: Optional[Literal[True]] = None,\n):\n    \"\"\"Close the key so it could be collected by the garbage collector afterwards.\n\n    Args:\n        key (str | Iterable[str], optional): key or keys that should be closed. Defaults to None.\n        every (True, optional): put to True if all keys should be closed. Defaults to None.\n\n    Raises:\n        ValueError: if both key and every are not provided.\n\n    Returns:\n        Self.\n    \"\"\"\n    if every is True:\n        for k in self.keys():\n            self.close_data(k)\n        return self\n    elif key is None:\n        raise ValueError(\"Should provide key or every=True.\")\n\n    if not isinstance(key, str):\n        for k in key:\n            self.close_data(k)\n        return self\n\n    if key not in self._unopened_keys:\n        self._data.pop(key)\n    self._unopened_keys.add(key)\n\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.get","title":"get","text":"<pre><code>get(key, default=None)\n</code></pre> <p>Retrieve the value associated with the given key from the DH5 object.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key to be searched.</p> required <code>default</code> <code>Any</code> <p>Value to be returned if the <code>key</code> is not found. The default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>The value associated with the key. If the value is a dict then it's converter</p> <code>Any</code> <p>into <code>DH5</code> object. This conversion take some time, but allow to change, save and</p> <code>Any</code> <p>this sub-object. For faster performance use <code>get_raw</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n&gt;&gt;&gt; sync_data.get('name')\n'John'\n&gt;&gt;&gt; sync_data.get('surname')\nNone\n&gt;&gt;&gt; sync_data.get('gender', 'unknown')\n'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def get(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Retrieve the value associated with the given key from the DH5 object.\n\n    Args:\n        key (str): Key to be searched.\n        default (Any, optional): Value to be returned if the `key` is not found.\n            The default value is `None`.\n\n    Returns:\n        The value associated with the key. If the value is a dict then it's converter\n        into `DH5` object. This conversion take some time, but allow to change, save and\n        this sub-object. For faster performance use `get_raw` method.\n\n    Examples:\n        &gt;&gt;&gt; sync_data = DH5(filepath='data.json', data={'name': 'John', 'age': 30})\n        &gt;&gt;&gt; sync_data.get('name')\n        'John'\n        &gt;&gt;&gt; sync_data.get('surname')\n        None\n        &gt;&gt;&gt; sync_data.get('gender', 'unknown')\n        'unknown' # Returns 'unknown' since 'gender' key doesn't exist\n\n    \"\"\"\n    data = self.__get_data__(key, default)\n    if isinstance(data, dict) and data:\n        return DH5(\n            filepath=self._filepath,\n            data=data,\n            overwrite=False,\n            key_prefix=key,\n            read_only=self.__check_read_only_true(key),\n        )\n    return data\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.get_raw","title":"get_raw","text":"<pre><code>get_raw(key, default=None)\n</code></pre> <p>Return raw value associated with the given key.</p> <p>Dictionaries are not converted to the <code>DH5</code> unlike <code>get</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Key to be searched.</p> required <code>default</code> <code>Any</code> <p>Value to be returned if the <code>key</code> is not found. The default value is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Raw value without any conversion or the default value if the key is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n&gt;&gt;&gt; sync_data.get_raw('key1')\n{'a': 1, 'b': 2}\n&gt;&gt;&gt; sync_data.get_raw('key2')\n5\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def get_raw(self, key: str, default: Any = None) -&gt; Any:\n    \"\"\"Return raw value associated with the given key.\n\n    Dictionaries are not converted to the `DH5` unlike `get` method.\n\n    Args:\n        key (str): Key to be searched.\n        default (Any, optional): Value to be returned if the `key` is not found.\n            The default value is `None`.\n\n\n    Returns:\n        Raw value without any conversion or the default value if the key is not found.\n\n    Examples:\n        &gt;&gt;&gt; sync_data = DH5({'key1':{'a': 1, 'b': 2}, 'key2': 5})\n        &gt;&gt;&gt; sync_data.get_raw('key1')\n        {'a': 1, 'b': 2}\n        &gt;&gt;&gt; sync_data.get_raw('key2')\n        5\n    \"\"\"\n    return self.__get_data__(key, default)\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.items","title":"items","text":"<pre><code>items()\n</code></pre> <p>Return all items in the collection.</p> <p>It opens all items that were not opened yet and return dictionary iterator.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def items(self):\n    \"\"\"Return all items in the collection.\n\n    It opens all items that were not opened yet and return dictionary iterator.\n    \"\"\"\n    if self._unopened_keys:\n        self._load_from_h5(key=self._unopened_keys)\n    return self._data.items()\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.keys","title":"keys","text":"<pre><code>keys()\n</code></pre> <p>Return all keys in the collection.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def keys(self) -&gt; Set[str]:\n    \"\"\"Return all keys in the collection.\"\"\"\n    # self.pull(auto=True)\n    return self._keys.copy().union(self._unopened_keys.copy())\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.keys_tree","title":"keys_tree","text":"<pre><code>keys_tree()\n</code></pre> <p>Return dict of the keys, where value always is a dict or None.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n&gt;&gt;&gt; sd.keys_tree()\n{'a': {'b': None}, 'c': None}\n</code></pre> <p>For all unopened keys, it does not open them and does not explore the structure.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def keys_tree(self) -&gt; Dict[str, Optional[dict]]:\n    \"\"\"Return dict of the keys, where value always is a dict or None.\n\n    Examples:\n        ```\n        &gt;&gt;&gt; sd = DH5({'a': {'b': 'value'}, 'c'})\n        &gt;&gt;&gt; sd.keys_tree()\n        {'a': {'b': None}, 'c': None}\n        ```\n\n    For all unopened keys, it does not open them and does not explore the structure.\n    \"\"\"\n    structure = get_keys_structure(self._data)\n\n    for key in self._unopened_keys:\n        structure[key] = None\n    return structure\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.load","title":"load","text":"<pre><code>load(filepath=None, key=None)\n</code></pre> <p>Load data from h5 into current object.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def load(\n    self, filepath: Optional[str] = None, key: Optional[Union[str, Set[str]]] = None\n):\n    \"\"\"Load data from h5 into current object.\"\"\"\n    updated_from_other_file = filepath is not None\n    updated_key = self._load_from_h5(filepath=filepath, key=key)\n    if updated_from_other_file:\n        for key in updated_key:\n            self._keys.add(key)\n\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.lock_data","title":"lock_data","text":"<pre><code>lock_data(keys=None)\n</code></pre> <p>Locks the specified keys in the database so they cannot be changed.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>Optional[Iterable[str]]</code> <p>An optional iterable of strings representing the keys to be locked.</p> <code>None</code> <p>Returns:</p> Type Description <code>_SELF</code> <p>A reference to the DH5 object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If everything is already locked by read_only mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n&gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n&gt;&gt;&gt; sd['key1'] = 2\nReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n&gt;&gt;&gt; sd['key2'] = 5\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def lock_data(self: _SELF, keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n    \"\"\"Locks the specified keys in the database so they cannot be changed.\n\n    Args:\n        keys: An optional iterable of strings representing the keys to be locked.\n        If None, all keys will be locked.\n\n    Returns:\n        A reference to the DH5 object.\n\n    Raises:\n        ValueError: If everything is already locked by read_only mode.\n\n    Examples:\n        &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n        &gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n        &gt;&gt;&gt; sd['key1'] = 2\n        ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n        &gt;&gt;&gt; sd['key2'] = 5\n\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\n            \"Cannot lock specific data and everything is locked by read_only mode\"\n        )\n    if not isinstance(self._read_only, set):\n        self._read_only = set()\n    if keys is None:\n        keys = self.keys()\n    elif isinstance(keys, str):\n        keys = (keys,)\n\n    for key in keys:\n        self._read_only.add(key)\n\n    self._clean_precalculated_results()\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.open_overwrite","title":"open_overwrite  <code>classmethod</code>","text":"<pre><code>open_overwrite(filepath_or_data=None, /, mode=None, *, filepath=None, save_on_edit=False, read_only=None, overwrite=True, data=None, open_on_init=None, **kwds)\n</code></pre> <p>Open file in the overwrite mode.</p> <p>It deletes the file if it exists and then opens it in the write mode. Same syntax as <code>__init__</code> method.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@classmethod\ndef open_overwrite(\n    cls,\n    filepath_or_data: Optional[Union[str, dict, Path]] = None,\n    /,\n    mode: Optional[Literal[\"=\"]] = None,\n    *,\n    filepath: Optional[Union[str, Path]] = None,\n    save_on_edit: bool = False,\n    read_only: Optional[Union[bool, Set[str]]] = None,\n    overwrite: Optional[bool] = True,\n    data: Optional[dict] = None,\n    open_on_init: Optional[bool] = None,\n    **kwds,\n):\n    \"\"\"Open file in the overwrite mode.\n\n    It deletes the file if it exists and then opens it in the write mode.\n    Same syntax as `__init__` method.\n    \"\"\"\n    mode_ = \"w=\" if mode == \"=\" else \"w\"\n    return cls(\n        filepath_or_data,\n        mode=mode_,\n        filepath=filepath,\n        save_on_edit=save_on_edit,\n        read_only=read_only,\n        overwrite=overwrite,\n        data=data,\n        open_on_init=open_on_init,\n        **kwds,\n    )\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.pop","title":"pop","text":"<pre><code>pop(key)\n</code></pre> <p>Remove the specified key and return the value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>Union[Any, NotLoaded]</code> <p>Same as <code>get</code> method, i.e. <code>DH5</code> if the value is a dict otherwise the value. If data was never loaded it will return <code>NotLoaded</code>. To load data use <code>get</code> method.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; data.pop('b')\n2\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef pop(self, key: str) -&gt; Union[Any, NotLoaded]:\n    \"\"\"Remove the specified key and return the value.\n\n    Args:\n        key (str): The key to remove.\n\n    Returns:\n        Same as `get` method, i.e. `DH5` if the value is a dict otherwise the value.\n            If data was never loaded it will return `NotLoaded`. To load data use `get` method.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n        &gt;&gt;&gt; data.pop('b')\n        2\n\n    \"\"\"\n    if self.__check_read_only_true(key):\n        raise ReadOnlyKeyError(key, action=\"pop\")\n    self.__del_key(key)\n    # self.pull(auto=True)\n    if key not in self._unopened_keys:\n        return self._data.pop(key)\n    return NotLoaded()\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.pull","title":"pull","text":"<pre><code>pull(force_pull=False)\n</code></pre> <p>Pull data from a file and reloads it into the object.</p> <p>Parameters:</p> Name Type Description Default <code>force_pull</code> <code>bool</code> <p>If True, forces to update data even if the file</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the filepath has not been set.</p> <p>Returns:</p> Name Type Description <code>self</code> <p>The updated object.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def pull(self, force_pull: bool = False):\n    \"\"\"Pull data from a file and reloads it into the object.\n\n    Args:\n        force_pull (bool, optional): If True, forces to update data even if the file\n        has not been modified. Defaults to False.\n\n    Raises:\n        ValueError: If the filepath has not been set.\n\n    Returns:\n        self: The updated object.\n    \"\"\"\n    if self.filepath is None:\n        raise ValueError(\"Cannot pull from file if it's not been set\")\n\n    if force_pull or self.pull_available():\n        logging.debug(\"File modified so it will be reloaded.\")\n        self._data = {}\n        self._keys = set()\n        self._clean_precalculated_results()\n        self._load_from_h5()\n\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.pull_available","title":"pull_available","text":"<pre><code>pull_available()\n</code></pre> <p>Check if the file has been modified elsewhere since the last save.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the filepath has not been set.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the file has been modified, False otherwise.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def pull_available(self):\n    \"\"\"Check if the file has been modified elsewhere since the last save.\n\n    Raises:\n        ValueError: If the filepath has not been set.\n\n    Returns:\n        bool: True if the file has been modified, False otherwise.\n    \"\"\"\n    if self.filepath is None:\n        raise ValueError(\"Cannot pull from file if it's not been set\")\n    file_modified = os.path.getmtime(self.filepath + \".h5\")\n    return self._file_modified_time != file_modified\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.remove","title":"remove","text":"<pre><code>remove(key)\n</code></pre> <p>Remove the specified key and self.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to remove.</p> required <p>Returns:</p> Type Description <code>_SELF</code> <p>Self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n&gt;&gt;&gt; data.pop('b')\nDH5({'a': 1, 'c': 3})\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef remove(self: _SELF, key: str) -&gt; _SELF:\n    \"\"\"Remove the specified key and self.\n\n    Args:\n        key (str): The key to remove.\n\n    Returns:\n        Self.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5({'a': 1, 'b': 2, 'c': 3})\n        &gt;&gt;&gt; data.pop('b')\n        DH5({'a': 1, 'c': 3})\n\n    \"\"\"\n    self.pop(key)\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.save","title":"save","text":"<pre><code>save(only_update=True, filepath=None, force=None)\n</code></pre> <p>Save the data to a file.</p> <p>Parameters:</p> Name Type Description Default <code>only_update</code> <code>Union[bool, Iterable[str]]</code> <p>Determines whether to save only the updated data or all data. If True, only the updated data will be saved. If False, all data will be saved. If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.</p> <code>True</code> <code>filepath</code> <code>str</code> <p>The path to the file where the data will be saved. If not provided, the default filepath will be used. Defaults to None.</p> <code>None</code> <code>force</code> <code>bool</code> <p>Determines whether to force the save operation, even if only_update is True. If True, the save operation will be forced. If False or None, the save operation will be performed according to the value of only_update. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <p>self</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file is opened in read-only mode, it cannot be saved. The file should be reopened in write mode before saving.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def save(\n    self,\n    only_update: Union[bool, Iterable[str]] = True,\n    filepath: Optional[str] = None,\n    force: Optional[bool] = None,\n):\n    \"\"\"Save the data to a file.\n\n    Args:\n        only_update (Union[bool, Iterable[str]], optional): Determines whether to save only\n            the updated data or all data.\n            If True, only the updated data will be saved. If False, all data will be saved.\n            If an iterable of strings is provided, only the specified keys will be saved. Defaults to True.\n        filepath (str, optional): The path to the file where the data will be saved.\n            If not provided, the default filepath will be used. Defaults to None.\n        force (bool, optional): Determines whether to force the save operation, even if only_update is True.\n            If True, the save operation will be forced. If False or None, the save operation\n            will be performed according to the value of only_update. Defaults to None.\n\n    Returns:\n        self\n\n    Raises:\n        ValueError: If the file is opened in read-only mode, it cannot be saved.\n            The file should be reopened in write mode before saving.\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\n            \"Cannot save opened in a read-only mode. Should reopen the file\"\n        )\n\n    self._pre_save()\n\n    if force is True or filepath is not None:\n        only_update = False\n\n    if isinstance(only_update, Iterable):\n        last_update = self._last_update.intersection(only_update)\n        self._last_update = self._last_update.difference(only_update)\n    else:\n        last_update, self._last_update = self._last_update, set()\n\n    if len(self._last_update) == 0:\n        self._last_data_saved = True\n\n    filepath = self._check_if_filepath_was_set(filepath, self._filepath)\n\n    if only_update is False:\n        if self._read_only is False:\n            data_to_save = self._data\n        else:\n            data_to_save = {\n                key: value\n                for key, value in self._data.items()\n                if key not in self._read_only or key in last_update\n            }\n        data_to_save.update(\n            {\n                key: None\n                for key in last_update\n                if (key not in self._data) and not self.__check_read_only_true(key)\n            }\n        )\n\n        self.__h5py_utils_save_dict_with_retry(filepath=filepath, data=data_to_save)\n\n        return self\n\n    for key in last_update:\n        if key in self._classes_should_be_saved_internally:\n            obj = self._data[key]\n            if hasattr(obj, \"save\"):\n                self._data[key].save(only_update=only_update)\n            else:\n                self._classes_should_be_saved_internally.remove(key)\n\n    self.__h5py_utils_save_dict_with_retry(\n        filepath=filepath,\n        data={\n            key: self._data.get(key)\n            for key in last_update\n            if key not in self._classes_should_be_saved_internally\n        },\n    )\n\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.unlock_data","title":"unlock_data","text":"<pre><code>unlock_data(remove_keys=None)\n</code></pre> <p>Unlock the specified keys in the database so they can be changed.</p> <p>If file was opened in read-only mode you cannot unlock it, however you can open it again in 'a' mode and lock all keys except necessary.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <p>An optional iterable of strings representing the keys to be unlocked.</p> required <p>Returns:</p> Type Description <code>_SELF</code> <p>A reference to the DH5 object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If everything is already locked by read_only mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n&gt;&gt;&gt; sd.lock_data()\n&gt;&gt;&gt; sd.unlock_data('key2')\n&gt;&gt;&gt; sd['key2'] = 5\n&gt;&gt;&gt; sd['key1'] = 2\nReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def unlock_data(self: _SELF, remove_keys: Optional[Iterable[str]] = None) -&gt; _SELF:\n    \"\"\"Unlock the specified keys in the database so they can be changed.\n\n    If file was opened in read-only mode you cannot unlock it, however you can open\n    it again in 'a' mode and lock all keys except necessary.\n\n    Args:\n        keys: An optional iterable of strings representing the keys to be unlocked.\n        If None, all keys will be unlocked.\n\n    Returns:\n        A reference to the DH5 object.\n\n    Raises:\n        ValueError: If everything is already locked by read_only mode.\n\n    Examples:\n        &gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n        &gt;&gt;&gt; sd.lock_data()\n        &gt;&gt;&gt; sd.unlock_data('key2')\n        &gt;&gt;&gt; sd['key2'] = 5\n        &gt;&gt;&gt; sd['key1'] = 2\n        ReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n\n    \"\"\"\n    if self._read_only is True:\n        raise ValueError(\"Cannot unlock is global read_only mode was set to True\")\n    if isinstance(self._read_only, set):\n        if remove_keys is None:\n            self._read_only = False\n        else:\n            if isinstance(remove_keys, str):\n                remove_keys = (remove_keys,)\n            for key in remove_keys:\n                if key in self._read_only:\n                    self._read_only.remove(key)\n\n    self._clean_precalculated_results()\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.update","title":"update","text":"<pre><code>update(__m=None, **kwds)\n</code></pre> <p>Update data from a dictionary or keyword arguments.</p> <p>See <code>DH5.data_transformation</code> to learn more     about how the types are converted.</p> <p>Parameters:</p> Name Type Description Default <code>__m</code> <code>dict | None</code> <p>A dictionary of key-value pairs to update the DH5 object with.</p> <code>None</code> <code>**kwds</code> <code>DICT_OR_LIST_LIKE</code> <p>Keyword arguments of key-value pairs to update the DH5 object with.</p> <code>{}</code> <p>Returns:</p> Type Description <code>_SELF</code> <p>Self.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = DH5()\n&gt;&gt;&gt; data.update({'a': 1, 'b': 2})\nDH5({'a': 1, 'b': 2})\n&gt;&gt;&gt; data.update(c=3, d=4)\nDH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n</code></pre> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>@editing\ndef update(\n    self: _SELF, __m: Optional[dict] = None, **kwds: \"DICT_OR_LIST_LIKE\"\n) -&gt; _SELF:\n    \"\"\"Update data from a dictionary or keyword arguments.\n\n    See `DH5.data_transformation` to learn more\n        about how the types are converted.\n\n    Args:\n        __m (dict | None): A dictionary of key-value pairs to update the DH5 object with.\n        **kwds (DICT_OR_LIST_LIKE): Keyword arguments of key-value pairs to update the DH5 object with.\n\n    Returns:\n        Self.\n\n    Examples:\n        &gt;&gt;&gt; data = DH5()\n        &gt;&gt;&gt; data.update({'a': 1, 'b': 2})\n        DH5({'a': 1, 'b': 2})\n        &gt;&gt;&gt; data.update(c=3, d=4)\n        DH5({'a': 1, 'b': 2, 'c': 3, 'd': 4})\n\n    \"\"\"\n    if __m is not None:\n        kwds.update(__m)\n\n    for key in kwds:  # pylint: disable=C0206\n        if self.__check_read_only_true(key):\n            raise ReadOnlyKeyError(key)\n        self.__add_key(key)\n        kwds[key] = transform_to_possible_formats(kwds[key])\n\n    # self.pull(auto=True)\n    self._data.update(**kwds)\n    return self\n</code></pre>"},{"location":"dh5/methods/#dh5.DH5.values","title":"values","text":"<pre><code>values()\n</code></pre> <p>Return all values in the collection.</p> <p>It opens all items that were not opened yet and return dictionary iterator.</p> Source code in <code>dh5/dh5_class/main.py</code> <pre><code>def values(self):\n    \"\"\"Return all values in the collection.\n\n    It opens all items that were not opened yet and return dictionary iterator.\n    \"\"\"\n    # self.pull(auto=True)\n    if self._unopened_keys:\n        self._load_from_h5(key=self._unopened_keys)\n    return self._data.values()\n</code></pre>"},{"location":"dh5/more/","title":"More on DH5.","text":""},{"location":"dh5/more/#more-functions","title":"More functions","text":"<ul> <li>h5 utils</li> </ul>"},{"location":"releases/","title":"Index","text":""},{"location":"releases/#080","title":"0.8.0","text":"<p>October 2023</p>"},{"location":"releases/#all-previous-versions-can-be-found-in-labmate-repository","title":"All previous versions can be found in labmate repository","text":"<p>Before this package was a part of the labmate repository, therefore all previous versions can be found there.</p>"},{"location":"starting_guide/advanced_examples/","title":"Advanced example","text":"<ul> <li>Different file loading mode (write, append, read)</li> <li>Partially load a file</li> </ul>"},{"location":"starting_guide/first_steps/","title":"Getting Started with DH5","text":"<p>Make sure you have installed the package before.</p>"},{"location":"starting_guide/first_steps/#writing-data","title":"Writing Data","text":"<p>To save data to an HDF5 file:</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', 'w')\n&gt;&gt;&gt; sd['a'] = 5\n&gt;&gt;&gt; sd.save()\n</code></pre> <p>Alternatively, use the <code>save_on_edit</code> option:</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', 'w', save_on_edit=True)\n&gt;&gt;&gt; sd['a'] = 5\n</code></pre> <p>If file already exists, you should prefer to use <code>open_overwrite</code> method to be more explicit.</p> <pre><code>&gt;&gt;&gt; sd = DH5.overwrite('somedata.h5', save_on_edit=True)\n&gt;&gt;&gt; sd['a'] = 5\n</code></pre>"},{"location":"starting_guide/first_steps/#reading-data","title":"Reading Data","text":"<p>Open an HDF5 file in read mode:</p> <pre><code>&gt;&gt;&gt; sd_read = DH5('somedata.h5', 'r')\n&gt;&gt;&gt; sd_read['a']  # Access data as an item\n5\n&gt;&gt;&gt; sd_read.a  # Access data as an attribute\n5\n</code></pre>"},{"location":"starting_guide/first_steps/#appending-data","title":"Appending Data","text":"<p>To add data to an existing HDF5 file:</p> <pre><code>&gt;&gt;&gt; sd_append = DH5('somedata.h5', 'a')\n&gt;&gt;&gt; sd_append['b'] = 6\n&gt;&gt;&gt; sd_append.save()\n</code></pre>"},{"location":"starting_guide/first_steps/#locking-keys","title":"Locking Keys","text":"<p>You can lock specific keys to prevent their modification:</p> <pre><code>&gt;&gt;&gt; sd = DH5({\"key1\": \"value1\", \"key2\": \"value2\"})\n&gt;&gt;&gt; sd.lock_data(['key1', 'key2'])\n&gt;&gt;&gt; sd['key1'] = 2  # This will raise an error\nReadOnlyKeyError: \"Cannot change a read-only key 'key1'.\"\n</code></pre> <p>To unlock a specific key:</p> <pre><code>&gt;&gt;&gt; sd.unlock_data('key2')\n&gt;&gt;&gt; sd['key2'] = 5\n</code></pre> <p>To lock all keys:</p> <pre><code>&gt;&gt;&gt; sd.lock_data()\n</code></pre>"},{"location":"starting_guide/first_steps/#h5nparray-synchronous-array-and-file-modification","title":"H5NpArray: Synchronous Array and File Modification","text":"<p>The <code>H5NpArray</code> class, integrated within the <code>H5PY</code> framework, allows for synchronous modification of <code>np.ndarray</code> and the corresponding file. When you change the array, the file is automatically updated, ensuring that your data is always in sync.</p>"},{"location":"starting_guide/first_steps/#guideline-for-h5nparray","title":"Guideline for H5NpArray","text":""},{"location":"starting_guide/first_steps/#open-file-in-write-mode","title":"Open File in Write Mode:","text":"<pre><code>from labmate.syncdata import SyncData\nsd = SyncData('tmp_data/test.h5', 'w', save_on_edit=True)\n</code></pre>"},{"location":"starting_guide/first_steps/#define-new-item-as-a-h5nparray","title":"Define New Item as a H5NpArray:","text":"<pre><code>shape = (100, 1000)\nsd['test_array'] = sd.h5nparray(np.zeros(shape))\n</code></pre> <p>The <code>H5NpArray</code> class requires an <code>np.array</code> as a parameter to initialize the data inside the file.</p>"},{"location":"starting_guide/first_steps/#modify-array-as-normal","title":"Modify Array as Normal","text":"<pre><code>for i in range(100):\n    sd['test_array'][i, :] = np.random.random(1000)\n# on each iteration only modified values are be saved.\n</code></pre>"},{"location":"starting_guide/first_steps/#verify-data-save","title":"Verify Data Save","text":"<pre><code>read = SyncData('tmp_data/test.h5')\nread['test_array'] # return the random array\n</code></pre>"},{"location":"starting_guide/first_steps/#further-details","title":"Further Details","text":"<p>To learn even more about how dh5 is structured, explore the Advanced Examples.</p>"},{"location":"starting_guide/install/","title":"Installation dh5","text":"<p>You can install the DH5 library using either pip or by pulling the repository directly from GitHub.</p>"},{"location":"starting_guide/install/#option-1-install-via-pip","title":"Option 1: Install via Pip","text":"<p>Open your terminal and run the following command</p> <pre><code>pip install dh5\n</code></pre>"},{"location":"starting_guide/install/#option-2-install-from-github","title":"Option 2: Install from GitHub","text":"<p>You can also install DH5 directly from its GitHub repository. This option is useful if you want to work with the latest development version or if you need to customize the library. Here's how to do it:</p> <ol> <li>Clone the DH5 repository from GitHub using the following command:</li> </ol> <pre><code>git clone https://github.com/kyrylo-gr/dh5.git\n</code></pre> <ol> <li>Enter the directory and install the package.</li> </ol> <pre><code>cd dh5\npip install .\n</code></pre> <p>Instead <code>pip install .</code> you can run <code>python setup.py develop</code> if you prefer.</p>"},{"location":"starting_guide/install/#thats-it","title":"That's it!","text":"<p>You've successfully installed the DH5 library. You can now start incorporating DH5 into your Python projects.</p> <p>For further insight, please refer to the First Steps guide.</p>"},{"location":"starting_guide/examples/different_modes/","title":"Different mode of file loading.","text":"<p>Modes can be set by providing <code>mode=..</code> keyword or explicitly by specifying <code>read_only</code> and <code>overwrite</code> options.</p> <p>'w' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False)\n</code></pre> <p>'a' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False, overwrite=False)\n</code></pre> <p>'r' mode is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=True)\n</code></pre> <p>DH5.open_overwrite method is the same as</p> <pre><code>&gt;&gt;&gt; sd = DH5('somedata.h5', read_only=False, overwrite=True)\nor\n&gt;&gt;&gt; sd = DH5('somedata.h5', mode='w', overwrite=True)\n</code></pre>"},{"location":"starting_guide/examples/partially_load/","title":"Partially load.","text":""},{"location":"starting_guide/examples/partially_load/#use-case","title":"Use case","text":"<p>You have a huge file that there's no need to open.</p> <p>Let's create file with some data:</p> <pre><code>data = {\"a\": 1, \"b\": 2}\ndh5.save(data, DATA_FILE_PATH, overwrite=True)\n</code></pre>"},{"location":"starting_guide/examples/partially_load/#open-file-without-loading-all","title":"Open file without loading all","text":"<p>Put <code>open_on_init=False</code></p> <pre><code>file = dh5.load(DATA_FILE_PATH, open_on_init=False)\n</code></pre> <p>In this case <code>file</code> consist of:</p> <pre><code>DH5 (r):\n {}\nUnloaded keys: {'b', 'a'}\n</code></pre>"},{"location":"starting_guide/examples/partially_load/#read-a-key","title":"Read a key","text":"<p>Use classical syntax to read a key and if it wasn't yet loaded it will be.</p> <pre><code>file[\"a\"]\n</code></pre>"},{"location":"types/","title":"Types.","text":"<p>See more:</p> <ul> <li>Numpy array</li> </ul>"},{"location":"types/h5nparray/","title":"H5NpArray","text":"<p>In <code>H5PY</code> <code>np.ndarray</code> can be saved as soon as modified. To do that there exists a class <code>H5NpArray</code>. This class synchronously modifies the np.ndarray and file.</p>"},{"location":"types/h5nparray/#guideline","title":"Guideline","text":"<ol> <li>Open file in write mode.</li> </ol> <pre><code>from DH5.DH5 import DH5\nsd = DH5('tmp_data/test.h5', overwrite=True, save_on_edit=False)\n</code></pre> <ol> <li>Define new item as a h5nparray</li> </ol> <pre><code>shape = (100, 1000)\nsd['test_array'] = sd.h5nparray(np.zeros(shape))\n</code></pre> <p><code>H5NpArray</code> takes the np.array as parameter to initialize the data inside the file.</p> <ol> <li>Modify as normal</li> </ol> <pre><code>for i in range(100):\n    sd['test_array'][i, :] = np.random.random(1000)\n</code></pre> <ol> <li>Check that data was saved</li> </ol> <pre><code>read = DH5('tmp_data/test.h5')\nread['test_array']\n</code></pre>"},{"location":"types/h5nparray/#implementation","title":"Implementation","text":"<ul> <li> <p><code>H5NpArray</code> has <code>__should_not_be_converted__=True</code>, which prevents <code>DH5</code> from converting it to an array and continuous using as a class</p> </li> <li> <p>as soon as you run <code>fd[key]</code> it will run method <code>__init__filepath__</code> to provide the filepath and the key to the class <code>H5NpArray</code></p> </li> </ul>"}]}